\documentclass[10pt, a4paper]{article}

\usepackage{longtable}
\usepackage{setspace}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[
	a4paper,
	top=2.5cm,
	bottom=2cm,
	left=2cm,
	right=2cm
]{geometry}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[
	colorlinks=true,
	linkcolor=black,
	urlcolor=blue
]{hyperref}
\usepackage{makecell}
\usepackage{float}
\usepackage[
	format=plain,
	labelfont=it,
	textfont=it
]{caption}
\usepackage{ifxetex}
\ifxetex
	\usepackage{fontspec}
	\setmainfont{Arial}
	\typeout{--> --> --> XeTeX detected: using Arial font <-- <-- <--}
\else
	\usepackage{helvet}
	\renewcommand{\familydefault}{\sfdefault}
\fi
\usepackage{amsmath}

%\usepackage[inline]{showlabels} % debugging purposes

\graphicspath{ {./pic} }

\singlespacing %interlinea

\def\arraystretch{1.5}
\renewcommand\theadfont{\bfseries}

\newcommand{\Intmaketable}[4]{
	\begin{longtable}{#3}
	#4
	\caption{#2}
	\label{#1}
	\end{longtable}
}

\newcommand{\Intceqtable}[3]{
	\Intmaketable{#1}{#2}{|l|l|}{
	\hline
	\thead{Parametro formale} & \thead{Classi d'equivalenza} \\
	\hline
	\hline
	#3
	\hline}
}

\newcommand{\Intbvtable}[3]{
	\Intmaketable{#1}{#2}{|l|l|l|}{
	\hline
	\thead{Parametro formale} & \thead{Classe d'equivalenza} & \thead{Boundary value}\\
	\hline
	\hline
	#3
	\hline}
}

\newcommand{\Inttestctable}[3]{
	\Intmaketable{#1}{#2}{|l|l|l|}{
	\hline
	\thead{Input} & \thead{Esito atteso} & \thead{Motivazione}\\
	\hline
	\hline
	#3
	\hline}
}

\newcommand{\Intreltable}[3]{
	\Intmaketable{#1}{#2}{|l|l|l|l|l|l|l|}{
	\hline
	\thead{Metodo} & \thead{\# test totali} & \thead{\# test pass.} & \thead{\# test fail.} & \thead{Rif. num. tab. prof. op.} &
	\thead{Distribuzione} & \thead{Reliability}\\
	\hline
	\hline
	#3
	\hline}
}

\newcommand{\Intceqcaption}[4]{Classi d'eq. per metodo #1 di #2, iter. #3 (#4)}
\newcommand{\Intbvcaption}[4]{Boundary values per classi d'eq. metodo #1 di #2, iter #3 (#4)}
\newcommand{\Inttestccaption}[4]{Casi di test per metodo #1 di #2, iter. #3 (#4)}
\newcommand{\Intrelcaption}[2]{Reliability ($1-PFD$) calcolata per ogni metodo della classe #1 (#2)}

%% BEGIN COMMANDS TO BE USED

%
% parameters
%  #1: target method
%  #2: target class
%  #3: num of iter
%  #4: proj name
%  #5: table content (see commands tcell, newtrow)
%

% use this to reference table in text
\newcommand{\gettablelabel}[5]{table:#1:#2:#3:iter#4:proj#5}

% use this to reference reliability summary table label
\newcommand{\getreltablelabel}[2]{\gettablelabel{#1}{}{}{}{#2}}

\newcommand{\ceqtable}[5]{
	\Intceqtable{\gettablelabel{ceq}{#1}{#2}{#3}{#4}}
		{\Intceqcaption{#1}{#2}{#3}{#4}}
		{#5}
}

\newcommand{\bvtable}[5]{
	\Intbvtable{\gettablelabel{bv}{#1}{#2}{#3}{#4}}
		{\Intbvcaption{#1}{#2}{#3}{#4}}
		{#5}
}

\newcommand{\testctable}[5]{
	\Inttestctable{\gettablelabel{testc}{#1}{#2}{#3}{#4}}
		{\Inttestccaption{#1}{#2}{#3}{#4}}
		{#5}
}

%
% parameters:
%  #1: class name
%  #2: project name
%  #3: table content
%

\newcommand{\reltable}[3] {
	\Intreltable{\getreltablelabel{#1}{#2}}
		{\Intrelcaption{#1}{#2}}
		{#3}
}

\newcommand{\unifdist}[1]{Uniforme: $#1$}

% use this to reference pictures in text
\newcommand{\getpicturelabel}[1]{picture:#1}

%
% parameters:
%  #1: width
%  #2: height
%  #3: file
%  #4: caption (see ctrdfcovcaption, alldfcovcaption, ...)
%

\newcommand{\makepicture}[4]{
	\begin{figure}[H]
	\centering
	\includegraphics[width=#1, height=#2]{#3}
	\caption{#4}
	\label{\getpicturelabel{#3}}
	\end{figure}
}

% use these to generate appropriate caption for pictures
\newcommand{\ctrdfcovcaption}[4]{Contatori copertura dataflow (def-use) per metodo #1 di #2, iter. #3 (#4)}
\newcommand{\alldfcovcaption}[4]{Vista completa per data-flow coverage (def-use) per metodo #1 di #2, iter. #3 (#4)}
\newcommand{\methodcfcovcaption}[4]{Statement coverage e branch coverage per metodo #1 di #2, iter. #3 (#4)}
\newcommand{\classcfcovcaption}[3]{Statement coverage e branch coverage per classe #1, iter. #2 (#3)}
\newcommand{\mutclasscaption}[3]{Statistiche sulla mutazione dell'intera classe #1, iter. #2 (#3)}
\newcommand{\mutmethodcaption}[6]{Mutanti (killed #5 su #6 totali) per il metodo #1 di #2, iter. #3 (#4)}
\newcommand{\finishcodecaption}[4]{codice di test per metodo #1 di #2 iter. #3 (#4)}

% use these to build table
\newcommand{\tcell}{\makecell[tl]}
\newcommand{\newtrow}{\\ \hline}

%% END OF COMMANDS TO BE USED

\def\reporttitle{Report ISW2 modulo testing}
\def\authorsname{Belli Stefano}
\def\univcode{0350116}

\title{\reporttitle}
\author{\authorsname\;(\univcode)}
\date{}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}

\fancyhead[LO,LE]{\authorsname}
\fancyhead[RO,LE]{\univcode}
\fancyfoot[CO,RE]{\thepage}

% use these when mentioning projects
\def\bookkeeper{BookKeeper}
\def\storm{Storm}
\def\asf{Apache Software Foundation}
\newcommand{\ceq}[1]{\{#1\}}

\setlength{\parindent}{0pt}

\begin{document}

	\maketitle
	\thispagestyle{empty}

	\tableofcontents

	\section*{Obiettivo del documento}
	L’obiettivo del documento è quello di illustrare tutte le attività svolte e le decisioni prese al fine ottenere una test suite
	adeguata e robusta, relativamente ai due progetti \bookkeeper e \storm (\asf). 
	Per entrambi i progetti è stato impostato il framework di continuous integration GitHub Actions – con un file YAML, 
	al cui interno viene specificato il SO, le “actions” che ad esempio si occupano di effettuare il checkout (git clone) del repo, 
	installare una certa versione di java, e i comandi da eseguire nella VM/container istanziato (a causa di un trigger, es. push di
	commit al repo remote). 
	Tramite l’ausilio di maven (in particolare i profili) e script scritti ad-hoc per il continuous integration, è stato possibile
	testare calcolando anche le metriche di adeguatezza control-flow, data-flow e effettuare mutazioni sui test. 
	I risultati vengono collezionati e caricati come artefatti della build
	(file html/xml di JaCoCo, PIT e ba-dua compressi in un archivio zip).
	Descrivere i sistemi testati non è coerente con lo scopo di questo documento, qualora fosse necessario ai fini 
	di motivare le scelte e le decisioni intraprese per individuare classi d’equivalenza, boundary analysis,\dots\,
	si riprenderanno i concetti del sistema di interesse. \textit{NOTA: nel documento, con "Estensione dei
	casi di test del metodo \dots " spesso si intende anche il miglioramento dei test}

	\pagebreak

	\section{Progetto \bookkeeper}
	Il readme del repository \href{https://github.com/apache/bookkeeper}{upstream} ne fornisce 
	la seguente definzione: \textit{“Apache BookKeeper is a scalable, 
	fault-tolerant and low latency storage service optimized for append-only workloads”}. 
	La documentazione di \href{https://bookkeeper.apache.org/archives/docs/master/bookkeeperOverview.html}{overview}
	fornisce una visione a grandi linee.
	Il source tree è diviso in vari artifact maven (ognuno ha un proprio pom.xml, la root ha il proprio pom.xml), 
	si decide di testare le classi dell'artifact bookkeeper-server. \\
	
	\subsection{org.apache.bookkeeper.net.NetworkTopologyImpl}
	Si decide di testare la classe perchè essendo \bookkeeper un sistema di ledger \underline{distribuiti}, è di fondamentale importanza l'organizzazione
	corretta dei "bookies" (server \bookkeeper) secondo una certa topologia di rete. La documentazione dell'
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopology.html}{interfaccia NetworkTopology} specifica i
	metodi che NetworkTopologyImpl deve necessariamente implementare. La classe implementor di nostro interesse (NetworkTopologyImpl) è documentata 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html}{qui} e si legge:
	\textit{"The class represents a cluster of computer with a tree hierarchical network topology. 
	For example, a cluster may be consists of many data centers filled with racks of computers. In a network topology, 
	leaves represent data nodes (computers) and inner nodes represent switches/routers that manage traffic in/out of data centers or racks."}.
	Per capire meglio, cercando nel web, ci si imbatte nella documentazione di 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/client/EnsemblePlacementPolicy.html}{EnsemblePlacementPolicy} 
	che contiene una spiegazione più dettagliata della "Network Topology": 
	\textit{"The network topology is presenting a cluster of bookies in a tree hierarchical structure. 
	For example, a bookie cluster may be consists of many data centers (aka regions) filled with racks of machines. 
	In this tree structure, leaves represent bookies and inner nodes represent switches/routes that manage traffic in/out of regions or racks.
	For example, there are 3 bookies in region `A`. They are `bk1`, `bk2` and `bk3`. And their network locations are /region-a/rack-1/bk1, 
	/region-a/rack-1/bk2 and /region-a/rack-2/bk3."} e rende tutto più chiaro (si veda anche la documentazione di \href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/Node.html}{Node}).
	Quindi, concettualmente si ha una rete strutturata ad albero.
	Un nodo foglia non può avere come parent il nodo ROOT, all'atto pratico questo significa che il bookie server deve essere necessariamente
	collocato in un rack/datacenter/\dots (collegato quindi a un router che rappresenti questo rack/datacenter/\dots), inserire un nodo tipo
	\textit{"/bookie-1"} (\underline{invalido}: essendo bookie$_1$ il server bookie/nodo foglia) non è consentito. 
	Inserire invece \textit{"/rack-1/bookie-1"} va bene (\underline{valido}), cosi come \textit{"/datacenter-1/
	rack-1/bookie-1"} (\underline{invalido}) e cosi via\dots Una volta stabilita l'altezza dell'albero (inserendo
	il primo ramo), non potranno essere inserite altre foglie ad altezza diversa.

	\subsubsection{Prima iterazione}
	Si decide di testare i metodi 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html#add(org.apache.bookkeeper.net.Node)}{add} e 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html#remove(org.apache.bookkeeper.net.Node)}{remove}
	di \href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html}{NetworkTopologyImpl} 
	perchè sono ritenuti i più importanti in quanto permettono di manipolare la topologia di rete aggiungendo e togliendo nodi.
	
	\textbf{Per il metodo add}: in tabella 
	\ref{\gettablelabel{ceq}{add}{NetworkTopologyImpl}{1}{\bookkeeper}}
	le classi d'equivalenza sono state scelte sulla base delle considerazioni fatte fino al paragrafo
	precedente sulla topologia di rete imposta da \bookkeeper\;(in particolare, in merito alla validità/non
	validità dei path dei nodes). In Java, qualsiasi riferimento ad
	un'oggetto può assumere valore null (tranne per i tipi primitivi), 
	che sarà quindi un valore da tenere quasi sempre in 
	considerazione dato che per alcuni metodi può avere un certo significato e/o conseguenze 
	sull'esecuzione. La tabella \ref{\gettablelabel{bv}{add}{NetworkTopologyImpl}{1}
	{\bookkeeper}} specifica i valori al bordo (la notazione \textit{Node("path")} presente in tabella indica
	istanze di nodi che puntano a quel path): in questo caso i nodi con path (non) valido, che (non) 
	passano il check di \underline{validazione} di NetworkTopologyImpl, sono molteplici, ma il valore al 
	bordo viene scelto per semplicità del percorso. 
	La tabella \ref{\gettablelabel{testc}{add}{NetworkTopologyImpl}{1}{\bookkeeper}}. 
	In tabella sono anche presentati
	gli esiti attesi con la motivazione - se l'esito atteso è:
	\begin{itemize}
		\item \textit{Nessuna variazione rispetto alla topologia attuale}: ci si aspetta che la 
		topologia prima e dopo l'esecuzione del metodo del SUT rimanga inalterata - nel nostro caso, 
		che la add avviene in una topologia di rete vuota, dopo l'esecuzione di add, ci si aspetta che 
		siano presenti 0 "racks" e 0 "leaves" (bookies) e il metodo del SUT che deve restituire il 
		riferimento al nodo in base al path cercato (\textit{"getNode"}) deve restituire null o eventualmente
		un nodo che non sia uguale a quello che si è tentato di inserire (spiegazione in fondo all'estensione
		dei casi di test del metodo add, seconda iterazione)
		\item \textit{Nessuna eccezione lanciata}: una eventuale eccezione (che sia checked o unchecked)
		inaspettata causa fallimento immediato dell'esecuzione del test.
		\item \textit{IllegalArgumentException lanciata}: mediante l'uso di \textit{assertThrows} di
		JUnit, ci si aspetta il lancio di una particolare eccezione da parte del metodo del SUT. Il
		non-lancio causa il fallimento immediato dell'asserzione e quindi dell'esecuzione del test.
		\item \textit{Aggiunta con successo del nodo alla rete}: sempre considerando che partiamo
		da una topologia di rete vuota - si verifica che siano presenti, dopo l'esecuzione del metodo
		del SUT, 1 "rack" e 1 "leave" (bookie), in più il metodo \textit{getNode} del SUT deve 
		restituire una reference all'oggetto che sia uguale a quella del nodo passato ad add.
	\end{itemize}
	
	Nella generazione dei casi di test è stato seguito un approccio unidimensionale.
	
	E' stato aggiunto un caso di test in più rispetto al boundary value della classe d'equivalenza di
	\{nodo con path valido\} al fine di testare inserimento del nodo ad un altezza diversa.
	
	Le condizioni di "nessuna variazione" e "IllegalArgumentException lanciata" vengono usate insieme
	in un caso: vengono verificate entrambe.	
	
	Nell'input, dove vengono specificati i parametri passati, viene usato il metodo buildNode che è:
	
	\textit{ BookieNode buildNode(String netLoc, String bookie) \{ return new
	BookieNode(BookieId.parse(bookie), netLoc); \} }
	
	\textbf{Per il metodo remove}: in tabella \ref{\gettablelabel{ceq}{remove}{NetworkTopologyImpl}{1}
	{\bookkeeper}}, le classi d'equivalenza sono state scelte pensando al fatto che un nodo per essere
	rimosso deve essere presente (è importante la verifica della presenza del nodo - il nodo è corretto rispetto
	alla configurazione del SUT attuale), non è quindi tanto 
	importante se il nodo passato abbia un path valido
	o meno - nella peggiore delle situazioni il nodo non viene trovato anche se il path è invalido (add 
	effettua validazione - se fallisce, il nodo non verrà inserito) e quindi non c'è nessuna 
	eliminazione.
	In tabella \ref{\gettablelabel{bv}{remove}{NetworkTopologyImpl}{1}{\bookkeeper}} sono stati scelti i valori al
	bordo con lo stesso criterio di add.
	La tabella \ref{\gettablelabel{testc}{remove}{NetworkTopologyImpl}{1}{\bookkeeper}} specifica i casi di test:
	le condizioni di esito atteso sono simili. Per eseguire il secondo test case, è stato necessario
	prima inserire nel SUT il nodo da rimuovere. L'esito atteso \textit{"rimozione con successo
	del nodo dalla rete"} prevede la verifica che dopo l'add sia presente nella rete 1 rack e 1 leave 
	(getNode sul path deve restituire come riferimento lo stesso oggetto Node passato ad add)
	quindi, dopo la delete, in rete devono esserci 0 rack, 0 leave e getNode sul path deve restiutire 
	null. Anche in questo caso, per la
	generazione dei test case è stato seguito l'approccio unidimensionale.
	
	Prima dell'esecuzione del metodo di add o remove (a seconda del metodo sottto test), ci si accerta 	
	che la topologia contenga un nodo o sia vuota (a seconda del test case da eseguire), come indicato
	dagli esiti attesi (es. \textit{"...ci si aspetta di partire da una topologia di rete vuota"}, 
	oppure \textit{"rimozione di un nodo effettivamente presente nella rete..."})
		
	Nella figura \ref{\getpicturelabel{bk/controlflow-NetworkTopologyImpl-1}} sono riportate la
	statement coverage e la branch coverage di tutta la classe NetworkTopologyImpl: in particolare,
	in figura \ref{\getpicturelabel{bk/controlflow-add-NetworkTopologyImpl-1}} per il metodo add e in
	figura \ref{\getpicturelabel{bk/controlflow-remove-NetworkTopologyImpl-1}} per il metodo remove.
	
	In figura \ref{\getpicturelabel{bk/mutation-NetworkTopologyImpl-1}} è riportato un summary degli
	score sulla mutazione dell'intera classe: in figura \ref{\getpicturelabel{bk/mutation-add-NetworkTopologyImpl-1}} 
	e \ref{\getpicturelabel{bk/mutation-remove-NetworkTopologyImpl-1}} vengono
	specificate le righe nelle quali PITest ha eseguito delle modifiche (mutanti) e quali di queste 
	modifiche sono state rilevate (killed, in verde) e quali no (in rosso). Nella caption viene 
	riportato
	il numero di mutanti killed su numero di mutanti totali. Bisogna considerare che se la riga è rossa
	e il numero riportato a sinistra sul numero di mutanti applicati alla riga è $>$ 1, allora bisogna
	controllare bene perchè se almeno uno è sopravvissuto, la riga diventa rossa (non andremmo a contare
	potenziali mutanti killed).
	
	In figura \ref{\getpicturelabel{bk/dataflow-add-NetworkTopologyImpl-1}} e 
	\ref{\getpicturelabel{bk/dataflow-remove-NetworkTopologyImpl-1}} 
	è riportata in dettaglio la data flow coverage per i metodi add e remove.
	
	\subsubsection{Seconda iterazione}
	In generale, osserviamo come sia la statement coverage (70\%), la data flow coverage (24 def-use 
	coperte su 32 totali) e il mutation
	score (6 mut. killed su 8 totali) del metodo remove siano molto migliori dei rispettivi del metodo
	add (52\%, 30 def-use coperte su 58 totali, 8 mut. killed su 14 totali).
	
	Dall'analisi del report di JaCoCo, si evince che i test eseguiti per add fin'ora, non hanno affrontato
	molti casi possibili di utilizzo. Per il metodo add si
	progettano altri test case, allo scopo di testare queste situazioni (in particolare quando la rete è
	popolata). Ci si pone l'obiettivo di aumentare la stmt. coverage e la branch coverage del
	metodo add.
	
	Per quanto riguarda il metodo remove, le metriche sono adeguate e si decide di non proseguire 
	con un ulteriore iterazione di stesura dei test case: i casi di utilizzo di remove di maggior interesse
	sono stati coperti dalla test suite.
	
	Data l'importanza della classe, si decide di testare anche i metodi 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html#getDistance(org.apache.bookkeeper.net.Node,org.apache.bookkeeper.net.Node)}
	{getDistance},
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html#pseudoSortByDistance(org.apache.bookkeeper.net.Node,org.apache.bookkeeper.net.Node[])}
	{pseudoSortByDistance}
	- la scelta è dettata dal fatto che \bookkeeper\;è un sistema distribuito e quindi i metodi in questione svolgono un ruolo cruciale
	nel cercare, ad esempio, un bookie a distanza minima che rispetti certi criteri per replicare le entries - se il metodo pseudoSortByDistance
	funziona erroneamente si avrà un peggioramento delle prestazioni (la topologia rispecchia la distanza fisica tra i bookies - risultati errati di pseudoSortByDistance corrispondono a diminuzione del rate di trasferimento dati).
	
	\textbf{Estensione casi di test metodo add}: osserviamo dalla 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html#add(org.apache.bookkeeper.net.Node)}
	{documentazione di add}
	che il metodo lancia IllegalArgumentException se il nodo da inserire non è una foglia, oppure si tenta
	di rendere una foglia esistente un parent ("appendendogli" una foglia) - per verificare che il metodo
	in queste condizioni abbia il comportamento atteso, bisogna estendere i casi di test: add deve validare il 
	nodo da inserire per la topologia di rete esistente - bisogna \underline{popolare la rete} prima di eseguire i test case. 
	E' un requisito di \bookkeeper\; che l'albero abbia tutti i rami alla stessa altezza.
	Che succede inoltre, se si prova ad inserire nodi con path già esistenti?
	\textit{Nella prima iterazione è stato possibile identificare un nodo con path non valido perchè per la topologia
	di rete "enforced" da \bookkeeper\; alla root non possono essere collegate delle foglie (prescinde l'albero
	di rete attuale)}
	
	\textit{Le tabelle per add e remove referenziate in questa seconda iterazione sono aggiuntive (non includono anche,
	ad esempio, le classi d'equivalenza o i test case generati dell'iterazione precedente, ma andranno considerate
	entrambe le tabelle per i profili operazionali e stima della reliability, a mo di unione tra set).}
	
	Prima dell'esecuzione dei test, viene generata una topologia di rete con altezza 3 (es. /dc-1/rack-1/bookie-1 
	è un leaf node della rete strutturata)
	
	In tabella \ref{\gettablelabel{ceq}{add}{NetworkTopologyImpl}{2}{\bookkeeper}} vengono specificate le
	classi d'equivalenza. Sono sufficienti queste 4 classi in quanto sufficienti a partizionare il dominio -
	il metodo non "capisce" la differenza tra /dc-1/rack-1 e /dc-1/bookie-1: se l'altezza del nodo da inserire
	è inferiore rispetto all'altezza dell'albero attuale, allora a prescindere il nodo non sarà una foglia, sia
	che si chiami "rack-1" che "bookie-1". Stessa cosa vale per l'inserimento di un nodo ad altezza superiore -
	può darsi che si tenti di rendere parent una foglia già esistente o di creare una nuova foglia ma ad altezza
	superiore. I boundary values in tabella \ref{\gettablelabel{bv}{add}{NetworkTopologyImpl}{2}{\bookkeeper}}
	sono stati generati per semplicità (es. non ha senso inserire un nodo ad altezza superiore che ha 10 livelli). In tabella \ref{\gettablelabel{testc}{add}{NetworkTopologyImpl}{2}{\bookkeeper}} sono presenti i test
	case generati. L'utilizzo di NodeBase è necessario perchè il metodo ausiliario buildNode usa il costruttore di
	BookieNode che a sua volta necessita di BookieId.parse che alla presenza di id del bookie non validi, lancia
	un'eccezione e non permette di proseguire col test del SUT (es. buildNode("/dc-2","") risulterebbe in eccezione per id del bookie non valido, ma è necessario per testare inserimento di inner node/router).
	
	Seguiamo anche qui un approccio unidimensionale alla generazione dei casi di test, e i significati
	degli esiti attesi sono identici a quelli descritti per add nell'iterazione precedente (ovviamente,
	relativamente alla "popolazione" della rete: se ad esempio si aggiunge un nodo, allora si verifica che
	vi siano prima $k$ nodi, poi, se ci si aspetta successo dell'inserimento, $k+1$ nodi)
	
	La motivazione per cui ci si aspetta che getNode, nel caso in cui l'inserimento fallisca, debba restituire
	null oppure un riferimento a un nodo diverso da quello di cui si è tentato l'inserimento è che getNode
	può restituire riferimenti a nodi anche non-foglia: se in una topologia ho un Node("/rack-1/bookie-1") allora
	avrò anche un nodo interno Node("/rack-1"): getNode sarà in grado di restituire la reference all'oggetto
	in questione. Se si prova a creare un \underline{nuovo} oggetto Node("/rack-1") (e quindi il suo inserimento),
	 e poi si tenta di effettuare
	l'asserzione che getNode("/rack-1") sia null, allora questa fallirà perchè un nodo con path "/rack-1" è
	effettiamente presente in rete, e ne verrà restituita la reference (ma ricordiamo, diversa da quella dell'
	oggetto di cui si è tentato l'inserimento). Nei test di add della prima iterazione, quest'aspetto è 
	indifferente, dato che la topologia è vuota.
	
	\textbf{Per il metodo getDistance}: In tabella 
	\ref{\gettablelabel{ceq}{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	sono presenti le classi d'equivalenza individuate, in tabella 
	\ref{\gettablelabel{bv}{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	i boundary values, 
	\ref{\gettablelabel{testc}{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	i test case generati.
	Le classi d'equivalenza sono state generate pensando agli utilizzi di
	getDistance e la sua gestione di parametri incorretti (un utilizzatore
	potrebbe per errore passare una reference null o costruire un nodo non
	appartenente alla rete e infatti è stato documentato come
	si comporta il metodo in quest'ultimo caso, quindi va verificato per 
	assicurarsi un corretto reporting all'utente). 
	I boundary values sono generati a partire da una
	rete prepopolata sulla quale eseguire il metodo per testarlo.
	Data la possibilità che \bookkeeper\; offre di gestire una rete gerarchica,
	potenzialmente su scala geografica, si è preferito optare per una rete 
	abbastanza alta da ricoprire questo caso di utilizzo (si pensi a grandi
	multinazionali).
	Per quanto riguarda i test case generati, è stato usato un approccio 
	multidimensionale e la differenza tra getNode e buildNode negli input, è
	che getNode viene usato sulla rete prepopolata per ottenere il riferimento
	al nodo di interesse, buildNode è un metodo statico che costruisce un nuovo
	nodo. Quando è presente buildNode, il nodo con quel path non è in rete (
	getNode restituirebbe null). Quello che è realmente di interesse è la distanza
	tra i bookies che interagiscono tra loro, e non tra i router, quindi,
	calcoliamo la distanza tra \textit{/europe/it/.../bookie-1} e 
	\textit{/europe/de/.../bookie-6} e cosi via\dots L'algoritmo per il calcolo 
	della distanza è descritto nella documentazione di getDistance: basta 
	individuare il common ancestor di entrambi i nodi e sommare il numero di hop 
	per arrivare da un nodo a un altro: per \textit{/italy/rack-1/bookie-1} e 
	\textit{/italy/rack-1/bookie-2} ad esempio, la distanza tra i due bookie è 2 
	perchè da \textit{bookie-1} \underline{vado} in \textit{rack-1} e poi da 
	\textit{rack-1} \underline{vado} in \textit{bookie-2}, non c'è bisogno di 
	effettuare ulteriori salti, essendo collegati allo stesso router/rack
	(tralasciando definizioni specifiche di rete). 
	Sulla base di questo algoritmo sono stati elaborati i valori di ritorno
	dei casi di test (dei nodi appartenenti alla rete). Negli altri casi,
	è stata seguita la documentazione dove possibile (ritorno di
	Integer.MAX\_VALUE) e sono state effettuate assunzioni dove non 
	specificato (gestione di null references).
	Gli esiti attesi sono auto-esplicativi (ritorno valore 0 e nessuna eccezione
	lanciata indicano una gestione passiva da parte del metodo di argomenti attuali non validi.)
	Purtroppo i test dal numero 2 al numero 8 falliscono: il metodo non gestisce
	le null reference come ci si aspetterebbe (viene lanciata
	NullPointerException) e non ritorna MAX\_VALUE se uno dei nodi non appartiene
	alla rete. Però c'è da precisare che nonostante nella reliability calcolata
	si considerino tutte le combinazioni dei valori usati come input in modo
	uniforme, è molto poco probabile che le combinazioni dei test falliti vengano
	effettivamente usate, il metodo, nella sua "configurazione" di utilizzo più
	probabile (entrambi i nodi appartenenti alla rete) passa tutti i test.
	
	\textbf{Per il metodo pseudoSortByDistance}: In tabella 
	\ref{\gettablelabel{ceq}{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	sono presenti le classi d'equivalenza individuate, in tabella 
	\ref{\gettablelabel{bv}{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	i boundary values, 
	\ref{\gettablelabel{testc}{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	i test case generati.
	Anche qui è stato usato un approccio multidimensionale alla generazione dei
	test case e sta volta, non è stato inclusa la classe d'equivalenza relativa
	a nodi non presenti in rete (sia per il reader che l'array di nodi da
	ordinare) in quanto di bassa probabilità di utilizzo, e allo scopo di ridurre
	il numero di test della test suite.
	La classe aggiuntiva che riguarda un array di nodi con almeno un nodo che sia
	null è utile perchè sta volta non è il riferimento all'array ad essere null,
	ma un suo elemento (la gestione non viene comunque specificata dalla
	documentazione) e questo può compromettere l'esecuzione del metodo (per
	dimenticanza o assunzione del programmatore è più facile pensare che se
	il riferimento all'array non è null allora nemmeno i suoi elementi lo saranno,
	portando a runtime errors nel caso in cui almeno un elemento sia null).
	Il sorting avviene sempre sui nodi della topologia prepopolata (uguale a quella
	del metodo getDistance). Per quanto riguarda la notazione, nei test case
	Array$<$Node$>$[ \dots ] è analogo a new Node[] \{ \dots \} in Java.
	L'esito atteso "Il metodo termina l'esecuzione nesuna eccezione lanciata"
	significa che l'esecuzione del metodo è praticamente una noop (ad esempio
	se il metodo termina e l'array passato era null, non posso verificare alcun
	ordinamento, 
	ci si aspetta solamente terminazione senza lancio di eccezioni). 
	L'implementazione del test è più complessa del normale perchè
	non basta osservare il sorting basato sulla distanza rispetto al reader:
	se il reader ha più di un nodo alla stessa distanza, questi ultimi (supponiamo ) due nodi possono essere posti da pseudoSortByDistance prima rispetto all'altro
	o viceversa - dato che l'implementazione di pseudoSortByDistance nel corso del tempo può cambiare,
	bisogna considerare esatto l'ordinamento anche se i due nodi alla stessa
	distanza sono scambiati rispetto a quanto previsto da noi (es. 
	se il nodo reader è \textit{/rack-1/bookie-1} e l'array è composto da \textit{/rack-1/bookie-2} e \textit{/rack-1/bookie-3} allora sia bookie-3 che bookie-2 possono 
	trovarsi nell'array sortato prima rispetto all'altro, dato che entrambi sono
	alla stessa distanza rispetto a bookie-1.
	Il calcolo della distanza è uguale a
	quello di getDistance.
	
	I test falliti di questo metodo sono tutti quelli che hanno come nodes 
	un array null (NullPointerException) - questo rivela un non-proper-checking
	degli argomenti passati al metodo.
	
	Nelle figure \ref{\getpicturelabel{bk/controlflow-NetworkTopologyImpl-2}}, \ref{\getpicturelabel{bk/controlflow-add-NetworkTopologyImpl-2}}, \ref{\getpicturelabel{bk/controlflow-getDistance-NetworkTopologyImpl-2}} e \ref{\getpicturelabel{bk/controlflow-pseudoSortByDistance-NetworkTopologyImpl-2}} si hanno la stmt. coverage e branch coverage che è aumentata sia per l'intera classe(50\%,51\%) che per il metodo add(71\%,81\%), come da obiettivo.
	Per getDistance si ottiene 69\%,60\% e pseudoSortByDistance 93\%,83\%.
	Nelle figure \ref{\getpicturelabel{bk/mutation-NetworkTopologyImpl-2}}, 
	\ref{\getpicturelabel{bk/mutation-add-NetworkTopologyImpl-2}},
	\ref{\getpicturelabel{bk/mutation-getDistance-NetworkTopologyImpl-2}},
	\ref{\getpicturelabel{bk/mutation-pseudoSortByDistance-NetworkTopologyImpl-2}} si ha il report di PIT per
	le mutazioni: per l'intera classe si ha un'incremento sia della mutation coverage, sia del test strength,
	mentre per add si ottiene un notevole incremento di mutanti killed: 13 su 14 totali.
	Per getDistance si ottengono invece 14 mut. killed su 23 totali (includendo anche quelli
	NO\_COVERAGE, i test non hanno coperto quella linea di codice per cui è stato creato il mutante), mentre per
	pseudoSortByDistance 13 mut. killed su 20 totali.
	Nella figura \ref{\getpicturelabel{bk/dataflow-add-NetworkTopologyImpl-2}} si ha la data flow coverage per add,
	in \ref{\getpicturelabel{bk/dataflow-getDistance-1-NetworkTopologyImpl-2}} per getDistance,
	in \ref{\getpicturelabel{bk/dataflow-getDistance-2-NetworkTopologyImpl-2}} per getDistance,
	in \ref{\getpicturelabel{bk/dataflow-pseudoSortByDistance-1-NetworkTopologyImpl-2}} per pseudoSortByDistance,
	in \ref{\getpicturelabel{bk/dataflow-pseudoSortByDistance-2-NetworkTopologyImpl-2}} per pseudoSortByDistance.
	Si hanno più report per la stessa classe quando vengono effettuati i test sulla stessa classe da diverse classi
	di test, quindi, per ottenere la copertura dataflow complessiva, bisogna sovrapporre i report. Viene fatto 
	per add (è avvenuta un estensione dei test su un'altra classe di test, quindi va contata complessivamente anche
	la classe dell'iterazione precedente), getDistance e pseudoSortByDistance.
	Ne risulta che il dataflow coverage è incrementato per add: 48 coppie coperte su 58 totali, per
	getDistance 42 coperte su 101 per pseudoSortByDistance 55 su 101.
	
	In tabella \ref{\getreltablelabel{NetworkTopologyImpl}{\bookkeeper}} è
	presente la reliabilty dei metodi testati. I test falliti vengono disattivati
	per terminare la build e ottenere informazioni sull'adeguatezza dei test e
	sulle mutazioni.

	\subsection{org.apache.bookkeeper.bookie.BufferedChannel}
	Dalla 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedChannel.html}
	{documentazione}: \textit{"Provides a buffering layer in front of a FileChannel"}.
	In altre parole, evita che un file venga scritto/letto continuamente, allocando due buffer in memoria:
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedChannel.html#writeBuffer}
	{writeBuffer} e 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedReadChannel.html#readBuffer}
	{readBuffer} (da BufferedReadChannel, dalla quale BufferedChannel eredita), con le loro rispettive capacità.
	
	Questa classe è stata scelta perchè cruciale ai fini di migliorare le prestazioni di \bookkeeper.
	
	Il costruttore invocato è \href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedChannel.html#\%3Cinit\%3E(io.netty.buffer.ByteBufAllocator,java.nio.channels.FileChannel,int)}
	{quello a 3 argomenti}.
	
	\subsubsection{Prima iterazione}
	Testiamo i metodi 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedChannel.html#read(io.netty.buffer.ByteBuf,long,int)}
	{read} e
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedChannel.html#write(io.netty.buffer.ByteBuf)}
	{write}
	dato che sono fondamentali per scrivere e leggere dai buffer.
	
	\textbf{Per il metodo write}: in tabella \ref{\gettablelabel{ceq}{write}{BufferedChannel}{1}{\bookkeeper}}
	vengono individuate le classi d'equivalenza, in tabella 
	\ref{\gettablelabel{bv}{write}{BufferedChannel}{1}{\bookkeeper}} 
	i boundary values, e i test case sono in tabella 
	\ref{\gettablelabel{testc}{write}{BufferedChannel}{1}{\bookkeeper}}.
	ByteBuf() è una classe di netty, documentata 
	\href{https://netty.io/4.0/api/io/netty/buffer/ByteBuf.html}{qui}, 
	e la notazione ByteBuf("...") indica la creazione di un buffer ByteBuf con quei bytes.
	L'esito atteso \textit{"NullPointerException viene lanciata"} è presente perchè è stato necessario
	guardare poco l'implementazione data la scarsa documentazione del metodo. Non viene effettuato alcun controllo
	sui parametri passati a write e quindi è lecito aspettarsi una NPE nel caso in cui src è null.
	L'esito atteso 
	\textit{"La scrittura nel buffer avviene con successo"}, 
	\textit{"La scrittura nel buffer avviene con successo dopo la precedente"} e 
	\textit{"La scrittura nel buffer avviene con successo dopo le precedenti due"}
	sono molto simili e stanno a significare che la "position"
	(come documentato 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedChannel.html#position()}
	{qui}) è aumentata pari al numero di byte scritti, cosi come il numero di bytes nel write buffer 
	(si veda 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedChannel.html#getNumOfBytesInWriteBuffer()}
	{qui}) e ci si aspetta di leggere, dal BufferedChannel, gli stessi dati appena scritti.
	Se il ByteBuf da cui prelevare i dati per la scrittura è vuoto (secondo test case), allora si verifica
	solamente che non siano variati position e il numero di bytes nel write buffer.
	
	\textbf{Per il metodo read}: in tabella \ref{\gettablelabel{ceq}{read}{BufferedChannel}{1}{\bookkeeper}}
	vengono individuate le classi d'equivalenza, in tabella 
	\ref{\gettablelabel{bv}{read}{BufferedChannel}{1}{\bookkeeper}} 
	i boundary values, e i test case sono in tabella 
	\ref{\gettablelabel{testc}{read}{BufferedChannel}{1}{\bookkeeper}}.
	La classe d'equivalenza \ceq{0} di length è stata inserita perchè, al contrario di pos che è un indice, 
	length per avere senso dovrebbe essere $\ge 1$.
	Si è optato per un approccio multidimensionale "filtrato": è inutile combinare la destinazione con reference
	null con le altre classi d'equivalenza e quindi è stato generato solo il primo test case che abbia come
	dest il valore null.
	La spiegazione dell'esito atteso \textit{"NullPointerException viene lanciata"} è uguale a quella fornita
	per il metodo write, mentre \textit{"IllegalArgumentException viene lanciata"} significa che dall'esecuzione
	del metodo ci si aspetta il lancio di IllegalArgumentException: non è presente nella documentazione, ma è
	una unchecked exception: può non essere presente nella throws clause di un metodo.
	I vari esiti \textit{"Buffer destinazione vuoto"} o 
	\textit{"Buffer destinazione contenente un byte uguale a quello in prima posizione del BufferedChannel"},\dots
	indicano la stessa cosa: 
	viene verificato quanto letto in una certa posizione, di una certa lunghezza, 
	con quanto ci si aspetta di trovare. 
	L'esito atteso \textit{"IOException viene lanciata"} indica che ci si aspetta il lancio di un'eccezione di tipo 
	IOException (presente nella throws clause del metodo: EOF) 
	se si legge il BufferedChannel oltre quanto scritto fin'ora. 
	Ovviamente, prima di eseguire i test viene scritto il buffer.
	In figura \ref{\getpicturelabel{bk/controlflow-BufferedChannel-1}} è presente la stmt coverage e la branch
	coverage dell'intera classe, mentre in figura \ref{\getpicturelabel{bk/controlflow-write-BufferedChannel-1}} e 
	\ref{\getpicturelabel{bk/controlflow-read-BufferedChannel-1}} per i metodi write e read, rispettivamente.
	In figura \ref{\getpicturelabel{bk/mutation-BufferedChannel-1}} si trovano statistiche sulle mutazioni
	applicate all'intera classe, mentre in figura \ref{\getpicturelabel{bk/mutation-write-BufferedChannel-1}} e 
	\ref{\getpicturelabel{bk/mutation-read-BufferedChannel-1}} per write e read.
	La data flow coverage è disponibile per i metodi write e read in figura 
	\ref{\getpicturelabel{bk/dataflow-write-BufferedChannel-1}} e 
	\ref{\getpicturelabel{bk/dataflow-read-BufferedChannel-1}}.
	Non è stata usata l'annotazione \textit{@RunWith(MockitoJUnitRunner.class)} nelle classi di test perchè
	non sono state necessarie le annotazioni \textit{@Mock} e \textit{@InjectMocks} per classi da "mockare" e
	verso le quali iniettare i mocks: è stato sufficiente usare Mockito.mock(\dots) per mockare FileChannel e poi
	passare l'istanza di FileChannel direttamente nel costruttore di BufferedChannel 
	(iniettando il mock "manualmente"). 
	Questo ha reso possibile l'utilizzo per i test del metodo read, dell'utilizzo dei test parametrizzati.
	I test falliti sono i primi 4 di read: non vengono gestiti in modo appropriato gli argomenti - il metodo
	permette l'utilizzo senza errori di argomenti illeciti - l'utilizzatore può pensare di star utilizzando
	correttamente il metodo quando in realtà non è cosi: il codice client può avere ripercussioni.
	
	\subsubsection{Seconda iterazione}
	Prima di procedere con la seconda iterazione, è opportuno fare qualche considerazione sull'adeguatezza
	dei test della prima iterazione: solo la stmt. coverage di write è alta (71\%).
	Analizzando il file HTML di JaCoCo (in particolare le cov. dei metodi read/write), ci rendiamo conto che
	questo succede perchè BufferedChannel
	è una classe che fa da wrapper a FileChannel - le scritture/letture verso il FileChannel vengono fondamentalmente
	effettuate quando il buffer è pieno/vuoto. Le mutazioni timed out presenti nella write
	sono (probabilmente) 
	dovute al fatto che il mock di FileChannel per ora restituisce sempre 0 per qualsiasi metodo (se viene
	forzato il flush mediante un mutante, il codice di flush rimmarrà bloccato in un loop dato che FileChannel
	restituirà sempre 0 come numero di byte copiati, non permettendo l'avanzamento del contatore del loop).
	
	Adesso si vuole testare l'effettivo funzionamento dei metodi quando si eccede la capacità del BufferedChannel,
	dato che, come evidente sopratutto dal file HTML di JaCoCo e PIT, questi casi non sono stati coperti.
	
	Si vogliono incrementare (almeno) la stmt. coverage e dataflow coverage dei metodi read e write.
	
	Il mock permetterà di simulare un FileChannel e il funzionamento
	dei suoi metodi. Tramite le facilities fornite da Mockito sarà anche possibile verificare quando e come i
	metodi dell'underlying FileChannel verranno invocati dal BufferedChannel (e quindi se queste invocazioni
	verranno effettuate correttamente, rispetto alla situazione).
	Di conseguenza, ci si aspetta un incremento di tutte le metriche di adeguatezza dei test e dei mutanti killed.
	
	Il BufferedChannel è un wrapper per FileChannel: vogliamo testare che i metodi read/write effettivamente
	interagiscano con il FileChannel quando necessario.
	
	Semplificando notevolmente:
	\begin{itemize}
		\item Si \textbf{scrive verso il FileChannel} quando il write buffer è pieno.
		\item Si \textbf{legge dal FileChannel} quando i dati richiesti non sono presenti ne nel 
		read buffer, ne nel write buffer.
	\end{itemize}
	
	E' stato necessario dare uno sguardo
	all'implementazione al fine di determinare queste informazioni, utili alla stesura dei test case di una
	funzionalità cruciale di BufferedChannel.
	
	Per quanto riguarda l'output dei metodi interessati, ci si aspettano letture/scritture in modo del tutto
	trasparente: quando leggo da una certa posizione del file, un certo numero di bytes, mi aspetto di leggere
	byte corretti, a prescindere dalla località delle informazioni (nel buffer di memoria o nella memoria di
	massa).
	
	\textbf{Estensione casi di test metodo write}: in tabella 
	\ref{\gettablelabel{ceq}{write}{BufferedChannel}{2}{\bookkeeper}},
	\ref{\gettablelabel{bv}{write}{BufferedChannel}{2}{\bookkeeper}} si trovano le classi d'equivalenza e i
	boundary values, che sono identici a quelli della prima iterazione.
	In tabella \ref{\gettablelabel{testc}{write}{BufferedChannel}{2}{\bookkeeper}} vengono riportati i test
	case, che indicano il valore che può causare o meno il flush del write buffer verso il file (invocazione
	metodo write di FileChannel).
	
	Gli esiti attesi indicano quanto segue:
	\begin{itemize}
		\item \textit{"Nessuna interazione con il FileChannel, 
		i dati passati al metodo in questa invocazione, vengono
		aggregati nel buffer di scrittura"}: il test case non provoca il flush -
		la quantità di dati scritta non è sufficiente a riempire il buffer.
		\item \textit{"Scrittura sul FileChannel del contenuto
		del buffer. I dati che "avanzano" rimangono nel buffer"}: il test case 
		provoca il flush - la quantità di dati scritta permette di riempire il
		buffer.
	\end{itemize}
	
	Prima dell'esecuzione del test case possono essere state eseguite più
	di una write per pre-riempire il buffer fino ad un certo punto (es. prima di un test
	case che prevede come esito atteso la scrittura sul FileChannel, vengono precaricati
	nel buffer una certa quantità di dati random, poi l'esecuzione del test case su quello
	stesso buffer provocherà il flush).
	\textit{Nota: nella colonna "Motivazione" della tabella dei test case, con "al momento della scrittura"
	si intende all'esecuzione del test case, con quel particolare input}.
	
	Se il test case prevede come esito atteso il 
	flush, ci si aspetta l'invocazione di FileChannel.write esattamente una volta
	da parte del codice di BufferedChannel, 2 volte di FileChannel.position, di trovare un certo numero di
	bytes rimanenti nel buffer (se ad esempio prima dell'esecuzione del test case nel buffer ho 60 bytes e
	il test case ne scrive altri 50, allora mi aspetto che, data una capacità di 100 bytes del buffer,
	dei 110 bytes totali, i primi 100 bytes vengano scritti sul FileChannel e gli ultimi 10 rimangano nel
	buffer in memoria). La posizione del write buffer deve avanzare, e anche quella del FileChannel.
	Ci si aspetta inoltre che verso il FileChannel vengano scritti esattamente quei primi 100 bytes,
	prelevandoli direttamente dalla "runnable" thenAnswer dell'oggetto mocked FileChannel (write)
	(es. se nel buffer ho 60 caratteri 'x' e invece nel test case ho 50 'h', allora mi aspetto che verso il
	FileChannel vengano flushati 'x' 60 volte e 'h' 40 volte).
	
	Se il test case prevede come esito atteso l'esclusiva aggregazione nel buffer, dato che non 
	viene riempito fino alla sua massima capacità, allora mi aspetto che FileChannel.write non venga mai chiamato,
	FileChannel.position venga chiamato solo 1 volta (nel costruttore di BufferedChannel), il numero di bytes
	nel write buffer è la quantità che già c'era prima più il num. di byte scritti dal test case, la posizione
	del write buffer avanza, mentre quella del FileChannel rimane a 0. Non viene scritto alcun dato nel
	FileChannel.
	
	\textbf{Estensione casi di test metodo read}: in tabella 
	\ref{\gettablelabel{ceq}{read}{BufferedChannel}{2}{\bookkeeper}}, 
	\ref{\gettablelabel{bv}{read}{BufferedChannel}{2}{\bookkeeper}} e 
	\ref{\gettablelabel{testc}{read}{BufferedChannel}{2}{\bookkeeper}}
	sono presenti classi d'eq., boundary values e test cases per la seconda iterazione. Le prime due sono
	simili a quanto elaborato per la prima iterazione. Sono stati filtrati alcuni casi di test 
	(e anche le classi d'eq. e boundary values) per cui read
	dovrebbe restituire errore (es. length < 0). I casi di test prevedono diverse combinazioni di length/pos:
	prima dell'esecuzione del test case verso il BufferedChannel 
	(i cui buffer interni sono di dimensione pari a 100 byte) avviene una scrittura di 300 byte (printabili)
	random (considerata la capacità del buffer interno di 100 byte, avverrà necessariamente almeno una flush) - 
	ci si aspetta che read ritorni una certa porzione
	(specificata tramite pos e length, esattamente come nella prima iter.) 
	di quei byte randomici scritti prima dell'esec. del test, in maniera del tutto
	trasparente - non ci importa se i byte sono ancora nel buffer di memoria o nel filesystem (gli esiti
	attesi in tabella sono autoesplicativi). Ovviamente l'approccio seguito nel generare i test case a questo
	punto è "randomico" (fatta eccezione per gli ultimi due test case), 
	senza far caso all'implementazione e a come avvenga la lettura (può avvenire dal buffer
	se i dati sono ancora disponibili, o caricati dal file). Essendo testato una volta sola la read e essendo
	le combinazioni possibili di pos/length infinite, ne sono state scelte solo alcune.
	Tramite Mockito è stato simulato FileChannel (write, position e read). 
	Non viene specificato negli esiti attesi, ma ci si accerta tramite verify di Mockito,
	che le invocazioni di metodi di FileChannel avvengano correttamente in base al test case 
	(es. se pos+len >= 100, la buffer size, allora ci si aspetta almeno una invocazione di FileChannel.read perchè 
	si sfora la capacity del BufferedChannel rispetto alla sua pos. attuale - 
	bisogna necessariamente prelevare il contenuto richiesto dal file).
	
	I test falliti espongono un malfunzionamento notevole di BufferedChannel: 
	in particolare il terz'ultimo e il penultimo test case, se abilitato, 
	manda la read di BufferedChannel in un endless loop. Questo avviene anche con
	altre combinazioni, che non sono state incluse nei test case, che ho provato per accertarmi del problema:
	per esempio la coppia 20, 279, la coppia 40, 260 o anche 40, 257, 
	ma \textbf{non} la coppia 40,256: anche provando la coppia 41,256 \textbf{non} ci sono problemi: sembra come
	se len > 256 causasse problemi. \textit{NOTA: ho provato anche senza mockare FileChannel e il risultato
	è stato lo stesso}.
	
	Nelle figure 
	\ref{\getpicturelabel{bk/controlflow-BufferedChannel-2}}, 
	\ref{\getpicturelabel{bk/controlflow-write-BufferedChannel-2}} e 
	\ref{\getpicturelabel{bk/controlflow-read-BufferedChannel-2}} è riportata la stmt.
	coverage e branch coverage di tutta la classe e singolarmente dei metodi write e read, dove possiamo notare
	un'incremento notevole di tutte e 6 le metriche, rispetto alla prima iterazione.
	Anche la line coverage, mutation coverage e il test strength di tutta la classe in figura
	\ref{\getpicturelabel{bk/mutation-BufferedChannel-2}} 
	è aumentata, cosi come il num. di mut. killed per i singoli metodi: in figura
	\ref{\getpicturelabel{bk/mutation-write-BufferedChannel-2}} (per write, 6 mut. killed su 13 totali) e in
	figura \ref{\getpicturelabel{bk/mutation-read-BufferedChannel-2}} (per read, 15 mut. killed su 26 totali).
	In figura \ref{\getpicturelabel{bk/mutation-write-BufferedChannel-2-timeout-cause}} è riportato il metodo
	che porterebbe al timeout per il metodo write durante il mutation testing (linea 130 figura
	\ref{\getpicturelabel{bk/mutation-write-BufferedChannel-2}}): la mutazione di negazione
	su hasRemaining (linea 202 figura \ref{\getpicturelabel{bk/mutation-write-BufferedChannel-2-timeout-cause}})
	causa un loop infinito dato che quando il mock legge dal ByteBuffer, lo consuma interamente (hasRemaining
	sarà sempre false e la negazione renderà l'espressione complessiva ottenuta sempre vera).
	
	La dataflow coverage di read è aumentata notevolmente (figura
	\ref{\getpicturelabel{bk/dataflow-read-BufferedChannel-2}}, 
	riportata in parte perchè impossibile da "fittare" completamente): 81 coppie defuse coperte / 118 totali.
	La dataflow coverage di write è anch'essa aumentata, anche se in misura minore (sovrapp. figure
	\ref{\getpicturelabel{bk/dataflow-write-1-BufferedChannel-2}} e
	\ref{\getpicturelabel{bk/dataflow-write-2-BufferedChannel-2}}): 31 coppie defuse coperte / 48 totali.
	
	Per realizzare questi test (sia per read che per write)
	e permettere la simulazione di FileChannel, è stato utilizzato Mockito e le
	sue facility (when, thenAnswer, thenReturn, verify, times, \dots).
	
	La stima della reliability è in tabella \ref{\getreltablelabel{BufferedChannel}{\bookkeeper}}
	
	\section{Progetto \storm}
	\href{https://storm.apache.org/}{Apache Storm} 
	è un sistema distribuito per il processamento realtime di dati. 
	E' scalabile, fault tolerant e sopratutto fornisce elevate prestazioni. 
	I \href{https://storm.apache.org/releases/current/Concepts.html}{concetti} 
	alla base di \storm\;sono: 
	\textbf{spout}(sorgente dati), 
	\textbf{tuple}(dati), 
	\textbf{stream}(composto da sequenze di tuple), 
	\textbf{bolt}(elemento di processamento sugli stream: 
		\textit{"All processing in topologies is done in bolts. Bolts can do anything from filtering, functions,
		aggregations, joins, talking to databases, and more."}),
	\textbf{topology}(un grafo di spouts e bolts, assimilabili a "nodi", connessi mediante streams aka "archi").
	
	Se necessario verranno presi in considerazione in modo più approfondito questi o altri concetti.
	
	\subsection{org.apache.storm.windowing.WindowManager}
	\storm\;supporta il windowing degli eventi: 
	ovvero il processamento di un sottoinsieme di tuple (\textit{eventi})  
	che rientrano in una finestra scorrevole 
	(\href{https://storm.apache.org/releases/1.2.3/Windowing.html}
	{\textit{Windowing Support in Core Storm}}).
	La gestione corretta della sliding window è cruciale al fine di garantire un corretto processamento
	delle tuple.
	
	La documentazione di riferimento per WindowManager è 
	\href{https://storm.apache.org/releases/2.6.2/javadocs/org/apache/storm/windowing/WindowManager.html}
	{questa}
	
	\subsubsection{Prima iterazione}
	Si sceglie di testare i metodi 
	\href{https://storm.apache.org/releases/2.6.2/javadocs/org/apache/storm/windowing/WindowManager.html#getSlidingCountTimestamps(long,long,int)}
	{getSlidingCountTimestamps} e
	\href{https://storm.apache.org/releases/2.6.2/javadocs/org/apache/storm/windowing/WindowManager.html#getEventCount(long)}
	{getEventCount}.
	
	Prima di testare i metodi indicati, vengono inseriti una serie di eventi in WindowManager.
	La eviction policy e la trigger policy al momento non sono di interesse.
	
	\textbf{Per il metodo getSlidingCountTimestamp}: 
	in tabella \ref{\gettablelabel{ceq}{getSlidingCountTimestamps}{WindowManager}{1}{\storm}} si hanno le
	classi d'equivalenza, in tabella \ref{\gettablelabel{bv}{getSlidingCountTimestamps}{WindowManager}{1}{\storm}} i 
	boundary values, in tabella \ref{\gettablelabel{testc}{getSlidingCountTimestamps}{WindowManager}{1}{\storm}} i test
	cases generati. L'approccio scelto alla generazione è stato multidimensionale. 
	\textit{NOTA: per ts(s) si intende timestamp(s)}
	Nella tabella dei boundary
	values, per il parametro formale "endTs", data la dipendenza da "startTs", si hanno 6 boundary values,
	sarebbero da dividere per il numero di classi d'eq. di "startTs" (2): ovvero, per "startTs" < 0 si hanno
	i corrispondenti "endTs" > 0, = 0, < 0. Stessa cosa per "startTs" $\ge$ 0. Questo si rifletterà sui test
	cases: il numero di test cases derivati direttamente dalla boundary values analysis non è 2 * 6 * 2 ma  
	2 * 3 * 2. La scelta di far dipendere la classe d'equivalenza di endTs con startTs è dettata dal fatto che,
	ovviamente, trattandosi di tempi, se si richiede un tempo iniziale, deve essere "prima" di un tempo finale.
	L'approccio multidimensionale permette inoltre di testare tutte le varie combinazioni e determinare se il
	metodo "si accorge" dei problemi legati ai valori attuali passati. Nei test cases, la notazione $t(e_k)$ indica
	l'istante in ms in cui si è verificato l'evento $e_k$. Invece $t(e_k) \pm a$ indica che all'istante in cui
	si è verificato l'evento $e_k$ si aggiungono $a$ millisecondi. Per descrivere i test cases generati 
	oltre a quelli derivati dalla boundary values analysis, bisogna precisare che WindowManager inserisce gli eventi
	in una struttura dati: verificandosi gli eventi in maniera temporale eventi successivi dovranno avere 
	necessariamente timestamp maggiore rispetto agli eventi precedenti. Il metodo testato, prevede due parametri in 
	particolare che sono startTs e endTs: i test sono stati generati facendo "scorrere" startTs e endTs: sugli eventi 
	verrificatosi: entrambi prima del ts del primo evento (con ts minore di tutti gli altri), con startTs prima del 
	primo evento e endTs dopo il ts del primo evento ma prima del ts dell'ultimo, startTs e endTs entrambi dopo il ts 
	del primo evento e prima dell'ultimo, e cosi via, fino a far arrivare sia startTs che endTs dopo il ts 
	dell'ultimo (con ts maggiore di tutti gli altri). 
	Il parametro slidingCount è meno documentato, ma serve a effetuare una selezione di timestamp da usare. 
	In particolare, se è 1 allora tutti gli eventi vengono considerati nel range di ts, se è 2 allora tutti gli
	eventi in posizione pari (contando per $k=1,2,3,\dots,n$), se è 3, vengono considerati gli eventi di posizione
	3,6,\dots (questo filtraggio viene effettuato DOPO il filtraggio dato dal ranging).
	Per gli esiti attesi: \textit{"IllegalArgumentException viene lanciata"} consiste nel verificare che il metodo
	effettivamente lanci quella particolare eccezione, mentre, con 
	\textit{"Ritorno lista di timestamp: $\{\dots,e_i,\dots\}$"} si intende una lista che contiene il timestamp
	dell'evento $i$-esimo $\forall i$, nello stesso ordine presentato nell'esito atteso, 
	\textit{"Ritorno lista di timestamp vuota"} è autoesplicativa.
	Nella motivazione non è scritto, ma bisogna ricordarsi che nella documentazione del metodo è riportato il
	fatto che l'intervallo è $(\text{startTs},\text{endTs}]$, ovvero, se in startTs passo il valore $t(e_1)$, allora
	il ts di $e_1$ non verrà mai inserito in lista, mentre lo potrà essere (slidingCount permettendo)
	se passo, ad esempio, $t(e_1) - 100$ (l'inclusione/esclusione è basata sul valore del timestamp passato).
	
	Prima dell'esecuzione dei test, vengono generati 10 eventi fittizi, alla quale vengono assegnati valori random
	con timestamp che partono da un valore di base (assegnato con 
	\href{https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#currentTimeMillis--}
	{System.currentTimeMillis}) e che avanza ogni volta
	di 200ms a partire dal tempo di base (ogni evento successivo è distanziato 200ms dal precedente).
	
	I primi 12 test (riferirsi alla tabella 
	\ref{\gettablelabel{testc}{getSlidingCountTimestamps}{WindowManager}{1}{\storm}})
	falliscono, la ragione è dovuta a una malagestione del check della validità degli argomenti attuali passati al
	metodo (i test falliscono perchè l'eccezione sollevata è IndexOutOfBoundsException, rivelando un tentativo di
	accesso a un array/vector/\dots errato). Comunque, nonoostante la stima della reliability è applicata su 
	prof. op. con dist. unif. (per semplicità) bisogna considerare il fatto che in realtà la prob. di utilizzare
	queste configurazioni di input è notevolmente più bassa di quanto stimato.
	
	\newpage
	\section{Link ai repository}
	\begin{itemize}
		\item BookKeeper: \url{https://github.com/StefanoBelli/bookkeeper}
		\begin{itemize}
			\item test localizzati in \textit{bookkeeper-server/src/test/java/\dots}
			\item CI (build$\;\rightarrow\;$test$\;\rightarrow\;$adequacy$\;\rightarrow\;$
			mutation$\;\rightarrow\;$report-packaging$\;\rightarrow\;$package-upload): 
			\url{https://github.com/StefanoBelli/bookkeeper/actions/workflows/ste-ci.yml} 
			(tra gli artifact c'è adequacy-reports.zip per ogni build triggerata)
		\end{itemize}
		\item Storm: \url{https://github.com/StefanoBelli/storm}
		\begin{itemize}
			\item test localizzati in \textit{storm-client/test/jvm/\dots}
			\item CI (build$\;\rightarrow\;$test$\;\rightarrow\;$adequacy$\;\rightarrow\;$
			mutation$\;\rightarrow\;$report-packaging$\;\rightarrow\;$package-upload): 
			\url{https://github.com/StefanoBelli/storm/actions/workflows/ste-ci.yml}
			(tra gli artifact c'è adequacy-reports.zip per ogni build triggerata)
		\end{itemize}
	\end{itemize}
	
	\newpage
	\section{Tabelle, figure e code listings}
	
	%
	% Iter: 1, Class: NetworkTopologyImpl, Project: Bookkeeper
	%
	
	\ceqtable{add}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{node} & \tcell{\ceq{null} \\ \ceq{nodo con path invalido} \\ \ceq{nodo con path valido} }
		\newtrow
	}
	
	\bvtable{add}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{node} & \tcell{\ceq{null}} & \tcell{null}
		\newtrow
			\tcell{node} & \tcell{\ceq{nodo con path invalido}} & \tcell{Node("/bookie-1")}
		\newtrow
			\tcell{node} & \tcell{\ceq{nodo con path valido}} & \tcell{Node("/rack-1/bookie-1")}
		\newtrow
	}
	
	\testctable{add}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{null} & \tcell{Nessuna variazione rispetto\\ alla topologia attuale,\\ nessuna 
			eccezione lanciata} & \tcell{Specifica della documentazione:\\ si prevede la gestione del 
			caso\\ in cui node sia null}
		\newtrow
			\tcell{buildNode("/rack-1","bookie-1")} & \tcell{Aggiunta con successo del nodo\\ alla rete} 
			& \tcell{Il nodo è una foglia (un server bk)\\ raggiungibile da /rack-1}
		\newtrow
			\tcell{buildNode("/","bookie-2")} & \tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\IllegalArgumentException viene\\ lanciata} & 
			\tcell{Il nodo è una foglia (un server bk)\\ ma non è raggiunta da un rack \\
			(è un requisito che il nodo foglia\\ non abbia come parent la root) }
		\newtrow
			\tcell{buildNode("/dc-1/rack-1", "bookie-3")} & \tcell{Aggiunta con successo del nodo\\ alla 
			rete} & \tcell{Il nodo è una foglia (un server bk)\\ raggiungibile da /dc-1/rack-1}
		\newtrow
	}
	
	\ceqtable{remove}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{node} & \tcell{\ceq{null}, \\ \ceq{nodo con path non presente in rete},\\ \ceq{nodo 
			con path presente in rete}}
		\newtrow
	}
	
	\pagebreak
	
	\bvtable{remove}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{node} & \tcell{\ceq{null}} & \tcell{null} 
		\newtrow
			\tcell{node} & \tcell{\ceq{nodo con path non presente in rete}} & \tcell{Node("/rack-1/bookie-1")}
		\newtrow
			\tcell{node} & \tcell{\ceq{nodo con path presente in rete}} & \tcell{Node("/rack-1/bookie-2")}
		\newtrow
	}
	
	\testctable{remove}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{null} & \tcell{Nessuna variazione rispetto\\ alla topologia attuale,\\ nessuna 
			eccezione lanciata} & \tcell{Specifica della documentazione:\\ si prevede la gestione del 
			caso\\ in cui node sia null}
		\newtrow
			\tcell{buildNode("/rack-1","bookie-1")} & \tcell{Rimozione con successo del nodo\\ dalla rete} & \tcell{Il nodo è una foglia (un server bk)\\ raggiungibile da /rack-1\\ aggiunto in precedenza}
		\newtrow
			\tcell{buildNode("/rack-1","bookie-2")} & \tcell{Nessuna variazione rispetto\\ alla topologia attuale,\\ nessuna eccezione lanciata} & \tcell{Il nodo è una foglia (un server bk)\\ raggiungibile da /rack-1\\ MA NON aggiunto in precedenza}
		\newtrow
	}	
	
	\makepicture{17cm}{1.15cm}{bk/controlflow-NetworkTopologyImpl-1}
				{\classcfcovcaption{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-add-NetworkTopologyImpl-1}
				{\methodcfcovcaption{add}{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-remove-NetworkTopologyImpl-1}
				{\methodcfcovcaption{remove}{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{17cm}{1.5cm}{bk/mutation-NetworkTopologyImpl-1}
				{\mutclasscaption{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{17cm}{15cm}{bk/mutation-add-NetworkTopologyImpl-1}
				{\mutmethodcaption{add}{NetworkTopologyImpl}{1}{\bookkeeper}{8}{14}}
	
	\makepicture{17cm}{10cm}{bk/mutation-remove-NetworkTopologyImpl-1}
				{\mutmethodcaption{remove}{NetworkTopologyImpl}{1}{\bookkeeper}{6}{8}}
				
	\makepicture{13cm}{23cm}{bk/dataflow-add-NetworkTopologyImpl-1}
				{\alldfcovcaption{add}{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{13cm}{15cm}{bk/dataflow-remove-NetworkTopologyImpl-1}
				{\alldfcovcaption{remove}{NetworkTopologyImpl}{1}{\bookkeeper}}

	%
	% Iter: 2, Class: NetworkTopologyImpl, Project: Bookkeeper
	%
	
	\ceqtable{add}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{node} & \tcell{
									\ceq{nodo con path ad altezza inferiore risp. alla topologia attuale} \\
									\ceq{nodo con path ad altezza superiore risp. alla topologia attuale} \\
									\ceq{nodo con path già esistente} \\
									\ceq{nodo con path valido risp. alla topologia attuale(uguale altezza) e non esistente}
								}
		\newtrow
	}
	
	\bvtable{add}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{node} & 
			\tcell{\ceq{nodo con path ad altezza inferiore\\ risp. alla topologia attuale}} &
			\tcell{Node("/rack-1/bookie-1")}
		\newtrow
			\tcell{node} &
			\tcell{\ceq{nodo con path ad altezza superiore\\ risp. alla topologia attuale}} &
			\tcell{Node("/region-1/dc-1/rack-1/bookie-1")}
		\newtrow
			\tcell{node} &
			\tcell{\ceq{nodo con path già esistente}} &
			\tcell{Node("/dc-1/rack-1/bookie-1")}
		\newtrow
			\tcell{node} &
			\tcell{\ceq{nodo con path valido risp.\\ alla topologia attuale\\(uguale altezza) e non esistente}} &
			\tcell{Node("/dc-3/rack-4/bookie-7")}
		\newtrow
	}
	
	\testctable{add}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{buildNode("/rack-1","bookie-1")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\InvalidTopologyException viene\\ lanciata} &
			\tcell{La documentazione specifica\\lancio di eccezione
			se il nodo\\ inserito non è una foglia\\ (altezza inferiore,\\
			tentativo di aggiunta foglia)}
		\newtrow
			\tcell{NodeBase("/dc-2")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\InvalidTopologyException viene\\ lanciata} &
			\tcell{La documentazione specifica\\lancio di eccezione
			se il nodo\\ inserito non è una foglia\\ (altezza inferiore,\\
			tentativo di aggiunta di un router)}
		\newtrow
			\tcell{NodeBase("/dc-3/rack-2")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\InvalidTopologyException viene\\ lanciata} &
			\tcell{La documentazione specifica\\lancio di eccezione
			se il nodo\\ inserito non è una foglia\\ (altezza inferiore,\\
			tentativo di aggiunta di un router)}
		\newtrow
			\tcell{buildNode("/region-1/dc-1/rack-1",\\"bookie-1")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\InvalidTopologyException viene\\ lanciata} &
			\tcell{La documentazione specifica\\lancio di eccezione
			se il nodo\\ ha altezza maggiore rispetto\\
			all'albero attuale}
		\newtrow
			\tcell{buildNode("/dc-1/rack-1/bookie-1",\\"another-bookie")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\InvalidTopologyException viene\\ lanciata} &
			\tcell{La documentazione specifica\\ lancio di eccezione
			se il nodo\\ ha come parent una foglia\\ esistente
			(un bookie non è un router)}
		\newtrow
			\tcell{buildNode("/dc-1/rack-1","bookie-1")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\ nulla a riguardo
			dell'inserimento\\  di nodi già esistenti, ma è ragionevole\\
			aspettarsi che il nodo da inserire\\ venga ignorato, dato che\\
			è già presente}
		\newtrow
			\tcell{buildNode("/dc-3/rack-4","bookie-7")} &
			\tcell{Aggiunta con successo del nodo\\ alla rete} &
			\tcell{Il nodo ha altezza coerente\\ con la topologia attuale e\\ 
			non esiste attualmente \\(/dc-3/rack-4 già esistenti,\\ ma non bookie-7)}
		\newtrow
			\tcell{buildNode("/dc-3/rack-5","bookie-8")} &
			\tcell{Aggiunta con successo del nodo\\ alla rete} &
			\tcell{Il nodo ha altezza coerente\\ con la topologia attuale e\\ 
			non esiste attualmente \\(/dc-3 già esistente,\\ ma non rack-5/bookie-8)}
		\newtrow
			\tcell{buildNode("/dc-4/rack-6","bookie-9")} &
			\tcell{Aggiunta con successo del nodo\\ alla rete} &
			\tcell{Il nodo ha altezza coerente\\ con la topologia attuale e\\ 
			non esiste attualmente \\(/dc-4/rack-6/bookie-9 non esistono)}
		\newtrow
			\tcell{buildNode("/dc-4/rack-6","bookie-7")} &
			\tcell{Aggiunta con successo del nodo\\ alla rete} &
			\tcell{Il nodo ha altezza coerente\\ con la topologia attuale e\\ 
			non esiste attualmente \\(Esiste un altro "bookie-7"\\ 
			\underline{MA in un altro ramo} dell'albero)}
		\newtrow
	}
	
	\ceqtable{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{node1} &
			\tcell{
				\ceq{null}\\
				\ceq{nodo appartenente alla rete} \\
				\ceq{nodo non appartenente alla rete}}
		\newtrow
			\tcell{node2} &
			\tcell{
				\ceq{null}\\
				\ceq{nodo appartenente alla rete} \\
				\ceq{nodo non appartenente alla rete}}
		\newtrow
	}
	
	\bvtable{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{node1} &
			\tcell{\ceq{null}} &
			\tcell{null}
		\newtrow
			\tcell{node1} &
			\tcell{\ceq{nodo appartenente alla rete}} &
			\tcell{Node("/europe/it/lazio/frosinone/rack-1/bookie-1")}
		\newtrow
			\tcell{node1} &
			\tcell{\ceq{nodo non appartenente alla rete}} &
			\tcell{Node("/asia/ru/region-1/moscow/rack-2/bookie-2")}
		\newtrow
			\tcell{node2} &
			\tcell{\ceq{null}} &
			\tcell{null}
		\newtrow
			\tcell{node2} &
			\tcell{\ceq{nodo appartenente alla rete}} &
			\tcell{Node("/europe/it/lazio/frosinone/rack-1/bookie-1")}
		\newtrow
			\tcell{node2} &
			\tcell{\ceq{nodo non appartenente alla rete}} &
			\tcell{Node("/asia/ru/region-1/moscow/rack-2/bookie-2")}
		\newtrow
	}
	
	\testctable{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{
					null, null} &
			\tcell{Ritorno valore 0,\\nessuna eccezione sollevata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/frosinone/\\rack-1/bookie-1"),\\
					null} &
			\tcell{Ritorno valore 0,\\nessuna eccezione sollevata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado (nodo non-null\\ esistente)}
		\newtrow
			\tcell{
					buildNode("/asia/ru/region-1/\\moscow/rack-2/bookie-2"),\\
					null} &
			\tcell{Ritorno valore 0,\\nessuna eccezione sollevata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado (nodo non-null\\ non-esistente)}
		\newtrow
			\tcell{
					null,\\
					getNode("/europe/it/lazio/frosinone/\\rack-1/bookie-1")} &
			\tcell{Ritorno valore 0,\\nessuna eccezione sollevata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado (nodo non-null\\ esistente)}
		\newtrow
			\tcell{
					null,\\
					buildNode("/asia/ru/region-1/\\moscow/rack-2/bookie-2")} &
			\tcell{Ritorno valore 0,\\nessuna eccezione sollevata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado (nodo non-null\\ non-esistente)}
		\newtrow
			\tcell{
					buildNode("/asia/ru/region-1/\\moscow/rack-2/bookie-2"),\\
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1")} &
			\tcell{Ritorno valore Integer.MAX\_VALUE} &
			\tcell{Il primo nodo non esiste\\ e la documentazione specifica\\ il ritorno di Integer.MAX\_VALUE}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					buildNode("/asia/ru/region-1/\\moscow/rack-2/bookie-2")} &
			\tcell{Ritorno valore Integer.MAX\_VALUE} &
			\tcell{Il secondo nodo non esiste\\ e la documentazione specifica\\ il ritorno di Integer.MAX\_VALUE}
		\newtrow
			\tcell{
					buildNode("/asia/cn/region-1/\\beijing/rack-1/bookie-1"),\\
					buildNode("/asia/ru/region-1/\\moscow/rack-2/bookie-2")} &
			\tcell{Ritorno valore Integer.MAX\_VALUE} &
			\tcell{Entrambi i nodi non esistono\\ 
			e la documentazione specifica\\ il ritorno di Integer.MAX\_VALUE}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1")} &
			\tcell{Ritorno valore 0} &
			\tcell{Il nodo è presente in rete:\\ come da documentazione,\\ dist. tra lo stesso nodo è 0}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-2")} &
			\tcell{Ritorno valore 2} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/it/lazio/\\roma/rack-2/bookie-3")} &
			\tcell{Ritorno valore 4} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/it/lazio/\\frosinone/rack-1/bookie-4")} &
			\tcell{Ritorno valore 6} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/it/lombardia/\\milano/rack-1/bookie-5")} &
			\tcell{Ritorno valore 8} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/de/region-1/\\berlino/rack-1/bookie-6")} &
			\tcell{Ritorno valore 10} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/america/us/california/\\paloalto/rack-2/bookie-7")} &
			\tcell{Ritorno valore 12} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
	}
	
	\ceqtable{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{reader} &
			\tcell{\ceq{null}\\\ceq{nodo presente in rete}}
		\newtrow
			\tcell{nodes} &
			\tcell{\ceq{null}\\\ceq{array con tutti i nodi al suo interno \\ 
			presenti in rete}\\\ceq{array con almeno un nodo\\al suo interno\\
			che sia null}}
		\newtrow
	}
	
	\bvtable{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{reader} & \tcell{\ceq{null}} & \tcell{null}
		\newtrow
			\tcell{reader} & \tcell{\ceq{nodo presente in rete}} & 
			\tcell{Node("/europe/it/lazio/roma/rack-1/bookie-1")}
		\newtrow
			\tcell{nodes} & \tcell{\ceq{null}} & \tcell{null}
		\newtrow
			\tcell{nodes} & \tcell{\ceq{array con tutti i nodi\\ al suo interno \\presenti in rete}} & 
			\tcell{Array$<$Node$>$[\\
					\;\;Node("/europe/it/lazio/roma/rack-1/bookie-1"),\\
					\;\;Node("/europe/it/lazio/roma/rack-1/bookie-2"),\\
					\;\;Node("/europe/it/lazio/roma/rack-2/bookie-3"),\\
					\;\;Node("/europe/it/lazio/frosinone/rack-3/bookie-4"),\\
					\;\;Node("/europe/it/lombardia/milano/rack-4/bookie-5"),\\
					\;\;Node("/europe/de/region-1/berlino/rack-5/bookie-6"),\\
					\;\;Node("/america/us/california/paloalto/rack-6/bookie-7")
					\\]}
		\newtrow
			\tcell{nodes} &
			\tcell{\ceq{array con almeno\\ un nodo al suo interno\\
			che sia null}} &
			\tcell{Array$<$Node$>$[\\\;\;null\\]}
		\newtrow
	}	
	
	\testctable{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{getNode("/europe/it/lazio\\/roma/rack-1/bookie-1"),\\
				Array$<$Node$>$[\\
					\;\;getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					\;\;getNode("/europe/it/lazio/\\roma/rack-1/bookie-2"),\\
					\;\;getNode("/europe/it/lazio/\\roma/rack-2/bookie-3"),\\
					\;\;getNode("/europe/it/lazio/\\frosinone/rack-3/bookie-4"),\\
					\;\;getNode("/europe/it/lombardia/\\milano/rack-4/bookie-5"),\\
					\;\;getNode("/europe/de/region-1/\\berlino/rack-5/bookie-6"),\\
					\;\;getNode("/america/us/california/\\paloalto/rack-6/bookie-7")
					\\]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttaamente in base\\
			 alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/europe/it/lazio/\\roma/rack-1/bookie-2"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/europe/it/lazio/\\roma/rack-2/bookie-3"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/europe/it/lazio/\\frosinone/rack-3/bookie-4"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/europe/it/lombardia/\\milano/rack-4/bookie-5"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/europe/de/region-1/\\berlino/rack-5/bookie-6"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/america/us/california/\\paloalto/rack-6/bookie-7"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{null, null} &
			\tcell{Il metodo termina l'esecuzione\\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
			\tcell{null, Array$<$Node$>$[null]} &
			\tcell{Il metodo termina l'esecuzione\\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
			\tcell{null, \\Array$<$Node$>$[\\\;\;getNode("/europe/it/lazio/\\roma/rack-1/bookie-1")\\]} &
			\tcell{Il metodo termina l'esecuzione\\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
			\tcell{getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"), null} &
			\tcell{Il metodo termina l'esecuzione\\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
			\tcell{getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\ Array$<$Node$>$[null]} &
			\tcell{Il metodo termina l'esecuzione\\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
	}
	
	\makepicture{17cm}{1.15cm}{bk/controlflow-NetworkTopologyImpl-2}
				{\classcfcovcaption{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-add-NetworkTopologyImpl-2}
				{\methodcfcovcaption{add}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-getDistance-NetworkTopologyImpl-2}
				{\methodcfcovcaption{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-pseudoSortByDistance-NetworkTopologyImpl-2}
				{\methodcfcovcaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{1.5cm}{bk/mutation-NetworkTopologyImpl-2}
				{\mutclasscaption{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{13cm}{bk/mutation-add-NetworkTopologyImpl-2}
				{\mutmethodcaption{add}{NetworkTopologyImpl}{2}{\bookkeeper}{13}{14}}
	
	\makepicture{13cm}{10cm}{bk/mutation-getDistance-NetworkTopologyImpl-2}
				{\mutmethodcaption{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{14}{23}}
	
	\makepicture{13cm}{10cm}{bk/mutation-pseudoSortByDistance-NetworkTopologyImpl-2}
				{\mutmethodcaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{13}{20}}
				
	\makepicture{8cm}{16cm}{bk/dataflow-add-NetworkTopologyImpl-2}
				{\alldfcovcaption{add}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{12cm}{24cm}{bk/dataflow-getDistance-1-NetworkTopologyImpl-2}
				{\alldfcovcaption{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{12cm}{24cm}{bk/dataflow-getDistance-2-NetworkTopologyImpl-2}
				{\alldfcovcaption{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{12cm}{24cm}{bk/dataflow-pseudoSortByDistance-1-NetworkTopologyImpl-2}
				{\alldfcovcaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{12cm}{24cm}{bk/dataflow-pseudoSortByDistance-2-NetworkTopologyImpl-2}
				{\alldfcovcaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
			
	\newpage
	\reltable{NetworkTopologyImpl}{\bookkeeper}{
			\tcell{add} &
			\tcell{$14$} &
			\tcell{$14$} &
			\tcell{$0$} &
			\tcell{
					tabella $\ref{\gettablelabel{testc}{add}{NetworkTopologyImpl}{1}{\bookkeeper}}$,
					tabella $\ref{\gettablelabel{testc}{add}{NetworkTopologyImpl}{2}{\bookkeeper}}$} &
			\tcell{\unifdist{0.07}} &
			\tcell{$1$}
		\newtrow	
			\tcell{remove} &
			\tcell{$3$} &
			\tcell{$3$} &
			\tcell{$0$} &
			\tcell{
					tabella $\ref{\gettablelabel{testc}{remove}{NetworkTopologyImpl}{1}{\bookkeeper}}$} &
			\tcell{\unifdist{0.33}} &
			\tcell{$1$}
		\newtrow
			\tcell{getDistance} &
			\tcell{$15$} &
			\tcell{$8$} &
			\tcell{$7$} &
			\tcell{
					tabella $\ref{\gettablelabel{testc}{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}$} &
			\tcell{\unifdist{0.067}} &
			\tcell{$0.531$}
		\newtrow
			\tcell{pseudoSort\\ByDistance} &
			\tcell{$12$} &
			\tcell{$10$} &
			\tcell{$2$} &
			\tcell{
					tabella $\ref{\gettablelabel{testc}{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}$} &
			\tcell{\unifdist{0.083}} &
			\tcell{$0.834$}
		\newtrow
	}
	
	%
	% Iter: 1, Class: BufferedChannel, Project: Bookkeeper
	%
	
	\ceqtable{write}{BufferedChannel}{1}{\bookkeeper}{
			\tcell{src} & \tcell{
				\ceq{null}\\
				\ceq{buffer t.c. $\text{lunghezza} \ge 0$}}
		\newtrow
	}
				
	\bvtable{write}{BufferedChannel}{1}{\bookkeeper}{
			\tcell{src} & \tcell{\ceq{null}} & \tcell{null}
		\newtrow
			\tcell{src} & \tcell{\ceq{buffer t.c. $\text{lunghezza} \ge 0$}} & \tcell{ByteBuf("")}
		\newtrow
	}
	
	\testctable{write}{BufferedChannel}{1}{\bookkeeper}{
			\tcell{null} & 
			\tcell{NullPointerException\\ viene lanciata} & 
			\tcell{
				La documentazione specifica\\ 
				che se una write operation\\
				fallisce, allora viene lanciata\\
				una IOException. Non viene\\
				specificato nulla a riguardo\\
				del parametro src.}
		\newtrow
			\tcell{ByteBuf("")} & 
			\tcell{
				La scrittura nel buffer\\ 
				avviene con successo} & 
			\tcell{}
		\newtrow
			\tcell{ByteBuf("random data")} &
			\tcell{
				La scrittura nel buffer\\ 
				avviene con successo} &
			\tcell{}
		\newtrow
			\tcell{ByteBuf("more random data")} &
			\tcell{
				La scrittura nel buffer\\ 
				avviene con successo\\
				dopo la precedente} &
			\tcell{}
		\newtrow
			\tcell{ByteBuf("again random data")} &
			\tcell{
				La scrittura nel buffer\\ 
				avviene con successo\\
				dopo le precedenti due} &
			\tcell{}
		\newtrow
	}
	
	\newpage
	
	\ceqtable{read}{BufferedChannel}{1}{\bookkeeper}{
			\tcell{dest} & \tcell{\ceq{null}\\\ceq{buffer di destinazione vuoto}}
		\newtrow
			\tcell{pos} & \tcell{\ceq{$< 0$},\ceq{$\ge 0$}}
		\newtrow
			\tcell{length} & \tcell{\ceq{$< 0$}, \ceq{$0$}, \ceq{$\ge 1$}}
		\newtrow
	}
	
	\bvtable{read}{BufferedChannel}{1}{\bookkeeper}{
			\tcell{dest} & \tcell{\ceq{null}} & \tcell{null}
		\newtrow
			\tcell{dest} & \tcell{\ceq{buffer di destinazione vuoto}} & \tcell{ByteBuf()}
		\newtrow
			\tcell{pos} & \tcell{\ceq{$< 0$}} & \tcell{$-1$}
		\newtrow
			\tcell{pos} & \tcell{\ceq{$\ge 0$}} & \tcell{$0$}
		\newtrow
			\tcell{length} & \tcell{\ceq{$< 0$}} & \tcell{$-1$}
		\newtrow
			\tcell{length} & \tcell{\ceq{$0$}} & \tcell{$0$}
		\newtrow
			\tcell{length} & \tcell{\ceq{$\ge 1$}} & \tcell{1}
		\newtrow
	}
	
	\testctable{read}{BufferedChannel}{1}{\bookkeeper}{
			\tcell{null, 0, 0} & 
			\tcell{NullPointerException viene lanciata} & 
			\tcell{
				La documentazione non specifica\\
				nulla a riguardo degli argomenti\\
				si assume comportamento simile a\\
				write} 
		\newtrow
			\tcell{ByteBuf(), -1, -1} & 
			\tcell{IllegalArgumentException viene lanciata} & 
			\tcell{pos e length non possono essere $<$ 0}	
		\newtrow
			\tcell{ByteBuf(), -1, 0} & 
			\tcell{IllegalArgumentException viene lanciata} & 
			\tcell{pos non può essere $<$ 0}
		\newtrow
			\tcell{ByteBuf(), 0, -1} & 
			\tcell{IllegalArgumentException viene lanciata} & 
			\tcell{length non può essere $<$ 0}
		\newtrow
			\tcell{ByteBuf(), 0, 0} & 
			\tcell{
				Buffer destinazione\\ 
				vuoto} & 
			\tcell{
				Lettura di 0 byte dalla\\
				posizione 0 lecita}
		\newtrow
			\tcell{ByteBuf(), 0, 1} & 
			\tcell{
				Buffer destinazione\\ 
				contenente un byte uguale\\ 
				a quello in prima\\ 
				posizione del BufferedChannel} & 
			 \tcell{
			 	Lettura di 1 byte dalla\\
			 	posizione 0}
		\newtrow
			\tcell{ByteBuf(), 0, 12} & 
			\tcell{
				Buffer destinazione\\ 
				contenente 12 byte uguali\\ 
				ai primi 12 del BufferedChannel} & 
			\tcell{
				Lettura di 12 byte dalla\\
				posizione 0}
		\newtrow
			\tcell{ByteBuf(), 1, 12} & 
			\tcell{
				Buffer destinazione\\ 
				contenente 12 byte uguali\\ 
				ai 12 byte consecutivi\\
				alla posizione 0\\ 
				del BufferedChannel} & 
			\tcell{
				Lettura di 12 byte dalla\\
				posizione 1}
		\newtrow
			\tcell{ByteBuf(), 10, 2} & 
			\tcell{
				Buffer destinazione\\ 
				contenente 2 byte uguali\\ 
				ai 2 byte consecutivi\\
				alla posizione 9\\ 
				del BufferedChannel} & 
			\tcell{
				Lettura di 2 byte dalla\\
				posizione 10}
		\newtrow
			\tcell{ByteBuf(), 0, 50} & 
			\tcell{
				Buffer destinazione\\ 
				contenente 50 byte uguali\\
				a quelli nel BufferedChannel\\
				(fino a num. di bytes correnti)} & 
			\tcell{
				Lettura di 50 byte dalla\\
				posizione 0}
		\newtrow
			\tcell{ByteBuf(), 40, 10} & 
			\tcell{
				Buffer destinazione\\ 
				contenente 10 byte uguali\\
				ai 10 byte consecutivi\\
				alla posizione 49 del\\
				a quelli nel BufferedChannel\\
				(fino a num. di bytes correnti)} & 
			\tcell{
				Lettura di 10 byte dalla\\
				posizione 40}
		\newtrow
			\tcell{ByteBuf(), 0, 51} & 
			\tcell{IOException viene lanciata} & 
			\tcell{
				La lettura eccede il numero\\
				di bytes scritti}
		\newtrow
			\tcell{ByteBuf(), 40, 11} & 
			\tcell{IOException viene lanciata} & 
			\tcell{
				La lettura eccede il numero\\
				di bytes scritti}
		\newtrow			
	}
	
	\makepicture{17.5cm}{1.15cm}{bk/controlflow-BufferedChannel-1}
				{\classcfcovcaption{BufferedChannel}{1}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-write-BufferedChannel-1}
				{\methodcfcovcaption{write}{BufferedChannel}{1}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-read-BufferedChannel-1}
				{\methodcfcovcaption{read}{BufferedChannel}{1}{\bookkeeper}}
				
	\makepicture{17cm}{1cm}{bk/mutation-BufferedChannel-1}
				{\mutclasscaption{BufferedChannel}{1}{\bookkeeper}}
				
	\makepicture{17cm}{10cm}{bk/mutation-write-BufferedChannel-1}
				{\mutmethodcaption{write}{BufferedChannel}{1}{\bookkeeper}{3}{13}}
	
	\makepicture{17cm}{12cm}{bk/mutation-read-BufferedChannel-1}
				{\mutmethodcaption{read}{BufferedChannel}{1}{\bookkeeper}{9}{26}}
				
	\makepicture{13cm}{23cm}{bk/dataflow-write-BufferedChannel-1}
				{\alldfcovcaption{write}{BufferedChannel}{1}{\bookkeeper}}
				
	\makepicture{10cm}{12cm}{bk/dataflow-read-BufferedChannel-1}
				{\alldfcovcaption{read}{BufferedChannel}{1}{\bookkeeper}}
				
	%
	% Iter: 2, Class: BufferedChannel, Project: Bookkeeper
	%
	
	\ceqtable{write}{BufferedChannel}{2}{\bookkeeper}{
			\tcell{src} & \tcell{
				\ceq{buffer a lunghezza $\ge 0$}}
		\newtrow
	}
				
	\bvtable{write}{BufferedChannel}{2}{\bookkeeper}{
			\tcell{src} & \tcell{\ceq{buffer a lunghezza $\ge 0$}} & \tcell{ByteBuf("")}
		\newtrow
	}
	
	\testctable{write}{BufferedChannel}{2}{\bookkeeper}{
			\tcell{ByteBuf("")} & 
			\tcell{
				Nessuna interazione con\\
				il FileChannel, i dati\\
				passati al metodo in questa\\
				invocazione, vengono aggregati\\
				nel buffer di scrittura} & 	
			\tcell{
				Il buffer di scrittura\\
				non si riempie, al momento\\
				della scrittura, il buffer\\
				è vuoto}
		\newtrow
			\tcell{ByteBuf("random data")} &
			\tcell{
				Nessuna interazione con\\
				il FileChannel, i dati\\
				passati al metodo in questa\\
				invocazione, vengono aggregati\\
				nel buffer di scrittura} &
			\tcell{
				Il buffer di scrittura\\
				non si riempie, al momento\\
				della scrittura, il buffer\\
				è vuoto}
		\newtrow
			\tcell{ByteBuf("more random data")} &
			\tcell{
				Nessuna interazione con\\
				il FileChannel, i dati\\
				passati al metodo in questa\\
				invocazione, vengono aggregati\\
				nel buffer di scrittura} &
			\tcell{
				Il buffer di scrittura\\
				non si riempie, al momento\\
				della scrittura, il buffer\\
				è stato scritto una volta}
		\newtrow
			\tcell{ByteBuf("datadatadata")} &
			\tcell{
				Nessuna interazione con\\
				il FileChannel, i dati\\
				passati al metodo in questa\\
				invocazione, vengono aggregati\\
				nel buffer di scrittura} &
			\tcell{
				Il buffer di scrittura\\
				non si riempie, al momento\\
				della scrittura, il buffer\\
				è stato scritto due volte}
		\newtrow
			\tcell{ByteBuf("again random data")} &
			\tcell{
				Scrittura sul FileChannel\\
				del contenuto del buffer.\\
				I dati che "avanzano"\\
				rimangono nel buffer.} &
			\tcell{
				Il buffer di scrittura\\
				è pieno, al momento\\
				della scrittura, il buffer\\
				è stato scritto una volta}
		\newtrow
			\tcell{ByteBuf("even more random data")} &
			\tcell{
				Scrittura sul FileChannel\\
				del contenuto del buffer.\\
				I dati che "avanzano"\\
				rimangono nel buffer.} &
			\tcell{
				Il buffer di scrittura\\
				è pieno, al momento\\
				della scrittura, il buffer\\
				è stato scritto due volta}
		\newtrow
			\tcell{ByteBuf(generateString(capacity+10))} &
			\tcell{
				Tutti i dati passati\\
				a questa invocazione\\
				di write devono essere\\
				scritti nel FileChannel.\\
				I dati che "avanzano"\\
				rimangono nel buffer.} &
			\tcell{
				Il buffer di scrittura, da vuoto,\\
				si riempie con una sola\\
				invocazione. Al momento\\
				della scrittura, il buffer\\
				è vuoto}
		\newtrow
	}
	
	\newpage
	
	\ceqtable{read}{BufferedChannel}{2}{\bookkeeper}{
			\tcell{dest} & \tcell{\ceq{buffer di destinazione vuoto}}
		\newtrow
			\tcell{pos} & \tcell{\ceq{$\ge 0$}}
		\newtrow
			\tcell{length} & \tcell{\ceq{$\ge 1$}}
		\newtrow
	}
	
	\bvtable{read}{BufferedChannel}{2}{\bookkeeper}{
			\tcell{dest} & \tcell{\ceq{buffer di destinazione vuoto}} & \tcell{ByteBuf()}
		\newtrow
			\tcell{pos} & \tcell{\ceq{$\ge 0$}} & \tcell{$0$}
		\newtrow
			\tcell{length} & \tcell{\ceq{$\ge 1$}} & \tcell{1}
		\newtrow
	}
	
	\testctable{read}{BufferedChannel}{2}{\bookkeeper}{
			\tcell{ByteBuf(), 0, 100} &
			\tcell{Buffer destinazione contenente\\
					i primi 100 byte del file} &
			\tcell{Lettura di 100 byte dalla\\posizione 0}
		\newtrow
			\tcell{ByteBuf(), 0, 140} &
			\tcell{Buffer destinazione contenente\\
					i primi 140 byte del file} &
			\tcell{Lettura di 140 byte dalla\\posizione 0}
		\newtrow
			\tcell{ByteBuf(), 105, 10} & 
			\tcell{Buffer destinazione\\ 
				contenente 10 byte uguali\\ 
				ai 10 byte consecutivi\\
				alla posizione 104\\ 
				del file} &
			\tcell{Lettura di 10 byte dalla\\posizione 105}
		\newtrow
			\tcell{ByteBuf(), 230, 70} & 
			\tcell{Buffer destinazione\\ 
				contenente 70 byte uguali\\ 
				ai 70 byte consecutivi\\
				alla posizione 229\\ 
				del file} &
			\tcell{Lettura di 70 byte dalla\\posizione 230}
		\newtrow
			\tcell{ByteBuf(), 70, 230} & 
			\tcell{Buffer destinazione\\ 
				contenente 230 byte uguali\\ 
				ai 230 byte consecutivi\\
				alla posizione 69\\ 
				del file} &
			\tcell{Lettura di 230 byte dalla\\posizione 70}
		\newtrow
			\tcell{ByteBuf(), 0, 300} &
			\tcell{Buffer destinazione contenente\\
					tutti i 300 byte del file} &
			\tcell{Lettura di 300 byte dalla\\posizione 0}
		\newtrow
			\tcell{ByteBuf(), 0, 301} &
			\tcell{IOException viene lanciata} &
			\tcell{
					La lettura eccede il numero\\
					di bytes scritti}
		\newtrow
			\tcell{ByteBuf(), 300, 1} &
			\tcell{IOException viene lanciata} &
			\tcell{
					La lettura eccede il numero\\
					di bytes scritti}
		\newtrow
	}
	
	\makepicture{17.5cm}{1.25cm}{bk/controlflow-BufferedChannel-2}
				{\classcfcovcaption{BufferedChannel}{2}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-write-BufferedChannel-2}
				{\methodcfcovcaption{write}{BufferedChannel}{2}{\bookkeeper}}
				
	\makepicture{17cm}{1cm}{bk/controlflow-read-BufferedChannel-2}
				{\methodcfcovcaption{read}{BufferedChannel}{2}{\bookkeeper}}
				
	\makepicture{17cm}{2cm}{bk/mutation-BufferedChannel-2}
				{\mutclasscaption{BufferedChannel}{2}{\bookkeeper}}
				
	\makepicture{17cm}{10cm}{bk/mutation-write-BufferedChannel-2}
				{\mutmethodcaption{write}{BufferedChannel}{2}{\bookkeeper}{6}{13}}
				
	\makepicture{17cm}{5cm}{bk/mutation-write-BufferedChannel-2-timeout-cause}
				{Possibile causa dei timeout dell'esecuzione delle mutazioni di write}
	
	\makepicture{17cm}{12cm}{bk/mutation-read-BufferedChannel-2}
				{\mutmethodcaption{read}{BufferedChannel}{2}{\bookkeeper}{15}{26}}
				
	\makepicture{13cm}{23cm}{bk/dataflow-write-1-BufferedChannel-2}
				{\alldfcovcaption{write}{BufferedChannel}{2}{\bookkeeper}}
				
	\makepicture{13cm}{23cm}{bk/dataflow-write-2-BufferedChannel-2}
				{\alldfcovcaption{write}{BufferedChannel}{2}{\bookkeeper}}
				
	\makepicture{13cm}{15cm}{bk/dataflow-read-BufferedChannel-2}
				{\alldfcovcaption{read}{BufferedChannel}{2}{\bookkeeper}}
				
	\reltable{BufferedChannel}{\bookkeeper}{
			\tcell{write} &
			\tcell{$12$} &
			\tcell{$12$} &
			\tcell{$0$} & 
			\tcell{
				tabella $\ref{\gettablelabel{testc}{write}{BufferedChannel}{1}{\bookkeeper}}$,
				tabella $\ref{\gettablelabel{testc}{write}{BufferedChannel}{2}{\bookkeeper}}$} &
			\tcell{\unifdist{0.083}} &
			\tcell{$1$}
		\newtrow	
			\tcell{read} &
			\tcell{$21$} &
			\tcell{$15$} &
			\tcell{$6$} &
			\tcell{
				tabella $\ref{\gettablelabel{testc}{read}{BufferedChannel}{1}{\bookkeeper}}$,
				tabella $\ref{\gettablelabel{testc}{read}{BufferedChannel}{2}{\bookkeeper}}$} &
			\tcell{\unifdist{0.048}} &
			\tcell{$0.7$}
		\newtrow
	}
	
	\newpage
	
	%
	% Iter: 1, Class: WindowManager, Project: Storm
	%
	
	\ceqtable{getSlidingCountTimestamps}{WindowManager}{1}{\storm}{
			\tcell{startTs} &
			\tcell{\ceq{$< 0$}\\\ceq{$\ge 0$}}
		\newtrow
			\tcell{endTs} &
			\tcell{\ceq{=startTs}\\\ceq{>startTs}\\\ceq{<startTs}} 
		\newtrow
			\tcell{slidingCount} &
			\tcell{\ceq{$< 0$}\\\ceq{$\ge 1$}}
		\newtrow
	}
	
	\bvtable{getSlidingCountTimestamps}{WindowManager}{1}{\storm}{
			\tcell{startTs} &
			\tcell{\ceq{$< 0$}} &
			\tcell{$-1$}
		\newtrow
			\tcell{startTs} &
			\tcell{\ceq{$\ge 0$}} &
			\tcell{$0$}
		\newtrow
			\tcell{endTs} &
			\tcell{\ceq{=startTs}} &
			\tcell{$-1$}
		\newtrow
			\tcell{endTs} &
			\tcell{\ceq{=startTs}} &
			\tcell{$0$}
		\newtrow
			\tcell{endTs} &
			\tcell{\ceq{>startTs}} &
			\tcell{$0$}
		\newtrow
			\tcell{endTs} &
			\tcell{\ceq{>startTs}} &
			\tcell{$1$}
		\newtrow
			\tcell{endTs} &
			\tcell{\ceq{<startTs}} &
			\tcell{$-2$}
		\newtrow
			\tcell{endTs} &
			\tcell{\ceq{<startTs}} &
			\tcell{$-1$}
		\newtrow
			\tcell{slidingCount} &
			\tcell{\ceq{$< 0$}} &
			\tcell{$-1$}
		\newtrow
			\tcell{slidingCount} &
			\tcell{\ceq{$\ge 1$}} &
			\tcell{$1$}
		\newtrow
	}
	
	\testctable{getSlidingCountTimestamps}{WindowManager}{1}{\storm}{
			\tcell{-1,-1,-1} &
			\tcell{IllegalArgumentException viene lanciata} &
			\tcell{startMs, endMs e slidingCount < 0}
		\newtrow
			\tcell{-1,0,-1} &
			\tcell{IllegalArgumentException viene lanciata} &
			\tcell{startMs e slidingCount < 0}
		\newtrow
			\tcell{-1,-2,-1} &
			\tcell{IllegalArgumentException viene lanciata} &
			\tcell{startMs, endMs e slidingCount < 0,\\ endMs < startMs}
		\newtrow
			\tcell{-1,-1,1} &
			\tcell{IllegalArgumentException viene lanciata} &
			\tcell{startMs e endMs < 0}
		\newtrow
			\tcell{-1,0,1} &
			\tcell{IllegalArgumentException viene lanciata} &
			\tcell{startMs < 0}
		\newtrow
			\tcell{-1,-2,1} &
			\tcell{IllegalArgumentException viene lanciata} &
			\tcell{startMs e endMs < 0,\\ endMs < startMs}
		\newtrow
			\tcell{0,0,-1} &
			\tcell{IllegalArgumentException viene lanciata} &
			\tcell{slidingCount < 0}
		\newtrow
			\tcell{0,1,-1} &
			\tcell{IllegalArgumentException viene lanciata} &
			\tcell{slidingCount < 0}
		\newtrow
			\tcell{0,-1,-1} &
			\tcell{IllegalArgumentException viene lanciata} &
			\tcell{endMs e slidingCount < 0,\\ endMs < startMs}
		\newtrow
			\tcell{0,0,1} &
			\tcell{Ritorno lista di timestamp vuota} &
			\tcell{endMs = startMs}
		\newtrow
			\tcell{0,1,1} &
			\tcell{Ritorno lista di timestamp vuota} &
			\tcell{Nessun evento ricade\\ nel range di timestamp}
		\newtrow
			\tcell{0,-1,1} &
			\tcell{IllegalArgumentException viene lanciata} &
			\tcell{endMs < 0,\\ endMs < startMs}
		\newtrow
			\tcell{$t(e_1)-100$, $t(e_1)-50$, 1} &
			\tcell{Ritorno lista di timestamp vuota} &
			\tcell{Nessun evento ricade\\ nel range di timestamp}
		\newtrow
			\tcell{$t(e_1)-100$, $t(e_1)+100$, 1} &
			\tcell{Ritorno lista di timestamp: $\{e_1\}$} &
			\tcell{L'evento $e_1$ ricade\\nel range di timestamp}
		\newtrow
			\tcell{$t(e_1)$, $t(e_3)$, 1} &
			\tcell{Ritorno lista di timestamp: $\{e_2,e_3\}$} &
			\tcell{Gli eventi $e_2$ ed $e_3$ ricadono\\ nel range di timestamp}
		\newtrow
			\tcell{$t(e_5)-100$, $t(e_8)+50$, 1} &
			\tcell{Ritorno lista di timestamp: $\{e_5,e_6,e_7,e_8\}$} &
			\tcell{Gli eventi $e_5,e_6,e_7,e_8$ ricadono\\ nel range di timestamp}
		\newtrow
			\tcell{$t(e_8)$, $t(e_{10})+100$, 1} &
			\tcell{Ritorno lista di timestamp: $\{e_9,e_{10}\}$} &
			\tcell{Gli eventi $e_9,e_{10}$ ricadono\\ nel range di timestamp}
		\newtrow
			\tcell{$t(e_{10})+100$, $t(e_{10})+200$, 1} &
			\tcell{Ritorno lista di timestamp vuota} &
			\tcell{Nessun evento ricade\\ nel range di timestamp}
		\newtrow
			\tcell{$t(e_1)-100$, $t(e_1)-50$, 2} &
			\tcell{Ritorno lista di timestamp vuota} &
			\tcell{Nessun evento ricade\\ nel range di timestamp}
		\newtrow
			\tcell{$t(e_1)-100$, $t(e_1)+100$, 2} &
			\tcell{Ritorno lista di timestamp vuota} &
			\tcell{L'evento $e_1$ ricade\\nel range di timestamp\\
			ma slidingCount=2\\impedisce al metodo\\ di considerare $e_1$}
		\newtrow
			\tcell{$t(e_1)$, $t(e_3)$, 2} &
			\tcell{Ritorno lista di timestamp: $\{e_3\}$} &
			\tcell{Gli eventi $e_2$ ed $e_3$ ricadono\\
			nel range di timestamp\\ma slidingCount=2\\impedisce al metodo\\ di considerare $e_2$}
		\newtrow
			\tcell{$t(e_5)-100$, $t(e_8)+50$, 2} &
			\tcell{Ritorno lista di timestamp: $\{e_6,e_8\}$} &
			\tcell{Gli eventi $e_5,e_6,e_7,e_8$ ricadono\\ nel range di timestamp\\
			ma slidingCount=2\\impedisce al metodo\\ di considerare $e_5,e_7$}
		\newtrow
			\tcell{$t(e_8)$, $t(e_{10})+100$, 2} &
			\tcell{Ritorno lista di timestamp: $\{e_{10}\}$} &
			\tcell{Gli eventi $e_9,e_{10}$ ricadono\\ nel range di timestamp\\
			ma slidingCount=2\\impedisce al metodo\\ di considerare $e_9$}
		\newtrow
			\tcell{$t(e_{10})+100$, $t(e_{10})+200$, 2} &
			\tcell{Ritorno lista di timestamp vuota} &
			\tcell{Nessun evento ricade\\ nel range di timestamp}
		\newtrow
	}
	
	\newpage
	
	\ceqtable{getEventCount}{WindowManager}{1}{\storm}{
			\tcell{referenceTime} & 
			\tcell{\ceq{$< 0$}\\\ceq{$\ge 0$}}
		\newtrow
	}
	
	\bvtable{getEventCount}{WindowManager}{1}{\storm}{
			\tcell{referenceTime} & 
			\tcell{\ceq{$< 0$}} &
			\tcell{$-1$}
		\newtrow
			\tcell{referenceTime} &
			\tcell{\ceq{$\ge 0$}} &
			\tcell{$0$}
		\newtrow
	}
	
	\testctable{getEventCount}{WindowManager}{1}{\storm}{
			\tcell{$-1$} &
			\tcell{IndexOutOfBoundsException viene lanciata} &
			\tcell{Non essendo specificato,\\ il comportamento si suppone essere\\ simile al metodo precedente}
		\newtrow
			\tcell{$0$} &
			\tcell{IndexOutOfBoundsException viene lanciata} &
			\tcell{Non essendo specificato,\\ il comportamento si suppone essere\\ simile al metodo precedente}
		\newtrow
			\tcell{$t(e_1)-100$} &
			\tcell{Ritorno valore 0} &
			\tcell{Nessun timestamp di evento\\ rientra ($t(e_1)$ è il minimo)}
		\newtrow
			\tcell{$t(e_1)$} &
			\tcell{Ritorno valore 1} &
			\tcell{Solo il timestamp $t(e_1)$ rientra}
		\newtrow
			\tcell{$t(e_5)$} &
			\tcell{Ritorno valore 5} &
			\tcell{I timestamp da $t(e_1)\dots t(e_5)$ rientrano}
		\newtrow
			\tcell{$t(e_{10})$} &
			\tcell{Ritorno valore 10} &
			\tcell{Tutti i timestamp di eventi\\ rientrano ($t(e_{10})$ è il massimo)}
		\newtrow
			\tcell{$t(e_{10})+100$} &
			\tcell{Ritorno valore 10} &
			\tcell{Tutti i timestamp di eventi\\ rientrano ($t(e_{10})$ è il massimo)}
		\newtrow
	}
	
	\newpage
	
\end{document}