\documentclass[10pt, a4paper]{article}

\usepackage{longtable}
\usepackage{setspace}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[
	a4paper,
	top=2.5cm,
	bottom=2cm,
	left=2cm,
	right=2cm
]{geometry}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage[
	colorlinks=true,
	linkcolor=black,
	urlcolor=blue
]{hyperref}
\usepackage{makecell}
\usepackage{float}
\usepackage[
	format=plain,
	labelfont=it,
	textfont=it
]{caption}
\usepackage{ifxetex}
\ifxetex
	\usepackage{fontspec}
	\setmainfont{Arial}
	\typeout{--> --> --> XeTeX detected: using Arial font <-- <-- <--}
\else
	\usepackage{helvet}
	\renewcommand{\familydefault}{\sfdefault}
\fi
\usepackage{amsmath}

%\usepackage[inline]{showlabels} % debugging purposes

\graphicspath{ {./pic} }

\singlespacing %interlinea

\def\arraystretch{1.5}
\renewcommand\theadfont{\bfseries}

\newcommand{\Intmaketable}[4]{
	\begin{longtable}{#3}
	#4
	\caption{#2}
	\label{#1}
	\end{longtable}
}

\newcommand{\Intceqtable}[3]{
	\Intmaketable{#1}{#2}{|l|l|}{
	\hline
	\thead{Parametro formale} & \thead{Classi d'equivalenza} \\
	\hline
	\hline
	#3
	\hline}
}

\newcommand{\Intbvtable}[3]{
	\Intmaketable{#1}{#2}{|l|l|l|}{
	\hline
	\thead{Parametro formale} & \thead{Classe d'equivalenza} & \thead{Boundary value}\\
	\hline
	\hline
	#3
	\hline}
}

\newcommand{\Inttestctable}[3]{
	\Intmaketable{#1}{#2}{|l|l|l|}{
	\hline
	\thead{Input} & \thead{Esito atteso} & \thead{Motivazione}\\
	\hline
	\hline
	#3
	\hline}
}

\newcommand{\Intreltable}[3]{
	\Intmaketable{#1}{#2}{|l|l|l|l|l|l|l|}{
	\hline
	\thead{Metodo} & \thead{\# test totali} & \thead{\# test pass.} & \thead{\# test fail.} & \thead{Rif. num. tab. prof. op.} &
	\thead{Distribuzione} & \thead{Reliability}\\
	\hline
	\hline
	#3
	\hline}
}

\newcommand{\Intceqcaption}[4]{Classi d'eq. per metodo #1 di #2, iter. #3 (#4)}
\newcommand{\Intbvcaption}[4]{Boundary values per classi d'eq. metodo #1 di #2, iter #3 (#4)}
\newcommand{\Inttestccaption}[4]{Casi di test per metodo #1 di #2, iter. #3 (#4)}
\newcommand{\Intrelcaption}[2]{Reliability ($1-PFD$) calcolata per ogni metodo della classe #1 (#2)}

%% BEGIN COMMANDS TO BE USED

%
% parameters
%  #1: target method
%  #2: target class
%  #3: num of iter
%  #4: proj name
%  #5: table content (see commands tcell, newtrow)
%

% use this to reference table in text
\newcommand{\gettablelabel}[5]{table:#1:#2:#3:iter#4:proj#5}

% use this to reference reliability summary table label
\newcommand{\getreltablelabel}[2]{\gettablelabel{#1}{}{}{}{#2}}

\newcommand{\ceqtable}[5]{
	\Intceqtable{\gettablelabel{ceq}{#1}{#2}{#3}{#4}}
		{\Intceqcaption{#1}{#2}{#3}{#4}}
		{#5}
}

\newcommand{\bvtable}[5]{
	\Intbvtable{\gettablelabel{bv}{#1}{#2}{#3}{#4}}
		{\Intbvcaption{#1}{#2}{#3}{#4}}
		{#5}
}

\newcommand{\testctable}[5]{
	\Inttestctable{\gettablelabel{testc}{#1}{#2}{#3}{#4}}
		{\Inttestccaption{#1}{#2}{#3}{#4}}
		{#5}
}

%
% parameters:
%  #1: class name
%  #2: project name
%  #3: table content
%

\newcommand{\reltable}[3] {
	\Intreltable{\getreltablelabel{#1}{#2}}
		{\Intrelcaption{#1}{#2}}
		{#3}
}

\newcommand{\unifdist}[1]{Uniforme: $#1$}

% use this to reference pictures in text
\newcommand{\getpicturelabel}[1]{picture:#1}

%
% parameters:
%  #1: width
%  #2: height
%  #3: file
%  #4: caption (see ctrdfcovcaption, alldfcovcaption, ...)
%

\newcommand{\makepicture}[4]{
	\begin{figure}[H]
	\centering
	\includegraphics[width=#1, height=#2]{#3}
	\caption{#4}
	\label{\getpicturelabel{#3}}
	\end{figure}
}

% use these to generate appropriate caption for pictures
\newcommand{\ctrdfcovcaption}[4]{Contatori copertura dataflow (def-use) per metodo #1 di #2, iter. #3 (#4)}
\newcommand{\alldfcovcaption}[4]{Vista completa per data-flow coverage (def-use) per metodo #1 di #2, iter. #3 (#4)}
\newcommand{\methodcfcovcaption}[4]{Statement coverage e branch coverage per metodo #1 di #2, iter. #3 (#4)}
\newcommand{\classcfcovcaption}[3]{Statement coverage e branch coverage per classe #1, iter. #2 (#3)}
\newcommand{\mutclasscaption}[3]{Statistiche sulla mutazione dell'intera classe #1, iter. #2 (#3)}
\newcommand{\mutmethodcaption}[6]{Mutanti (killed #5 su #6 totali) per il metodo #1 di #2, iter. #3 (#4)}
\newcommand{\finishcodecaption}[4]{codice di test per metodo #1 di #2 iter. #3 (#4)}

% use these to build table
\newcommand{\tcell}{\makecell[tl]}
\newcommand{\newtrow}{\\ \hline}

%% END OF COMMANDS TO BE USED

\def\reporttitle{Report ISW2 modulo testing}
\def\authorsname{Belli Stefano}
\def\univcode{0350116}

\title{\reporttitle}
\author{\authorsname\;(\univcode)}
\date{}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}

\fancyhead[LO,LE]{\authorsname}
\fancyhead[RO,LE]{\univcode}
\fancyfoot[CO,RE]{\thepage}

% use these when mentioning projects
\def\bookkeeper{BookKeeper}
\def\storm{Storm}
\def\asf{Apache Software Foundation}
\newcommand{\ceq}[1]{\{#1\}}

\setlength{\parindent}{0pt}

\begin{document}

	\maketitle
	\thispagestyle{empty}

	\tableofcontents

	\section*{Obiettivo del documento}
	L’obiettivo del documento è quello di illustrare tutte le attività svolte e le decisioni prese al fine ottenere una test suite
	adeguata e robusta, relativamente ai due progetti \bookkeeper e \storm (\asf). 
	Per entrambi i progetti è stato impostato il framework di continuous integration GitHub Actions – con un file YAML, 
	al cui interno viene specificato il SO, le “actions” che ad esempio si occupano di effettuare il checkout (git clone) del repo, 
	installare una certa versione di java, e i comandi da eseguire nella VM/container istanziato (a causa di un trigger, es. push di
	commit al repo remote). 
	Tramite l’ausilio di maven (in particolare i profili) e script scritti ad-hoc per il continuous integration, è stato possibile
	testare calcolando anche le metriche di adeguatezza control-flow, data-flow e effettuare mutazioni sui test. 
	I risultati vengono collezionati e caricati come artefatti della build
	(file html/xml di JaCoCo, PIT e ba-dua compressi in un archivio zip).
	Descrivere i sistemi testati non è coerente con lo scopo di questo documento, qualora fosse necessario ai fini 
	di motivare le scelte e le decisioni intraprese per individuare classi d’equivalenza, boundary analysis,\dots\,
	si riprenderanno i concetti del sistema di interesse.

	\pagebreak

	\section{Progetto \bookkeeper}
	Il readme del repository \href{https://github.com/apache/bookkeeper}{upstream} ne fornisce 
	la seguente definzione: \textit{“Apache BookKeeper is a scalable, 
	fault-tolerant and low latency storage service optimized for append-only workloads”}. 
	La documentazione di \href{https://bookkeeper.apache.org/archives/docs/master/bookkeeperOverview.html}{overview}
	fornisce una visione a grandi linee.
	Il source tree è diviso in vari artifact maven (ognuno ha un proprio pom.xml, la root ha il proprio pom.xml), 
	si decide di testare le classi dell'artifact bookkeeper-server. \\
	
	\subsection{org.apache.bookkeeper.net.NetworkTopologyImpl}
	Si decide di testare la classe perchè essendo \bookkeeper un sistema di ledger \underline{distribuiti}, è di fondamentale importanza l'organizzazione
	corretta dei "bookies" (server \bookkeeper) secondo una certa topologia di rete. La documentazione dell'
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopology.html}{interfaccia NetworkTopology} specifica i
	metodi che NetworkTopologyImpl deve necessariamente implementare. La classe implementor di nostro interesse (NetworkTopologyImpl) è documentata 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html}{qui} e si legge:
	\textit{"The class represents a cluster of computer with a tree hierarchical network topology. 
	For example, a cluster may be consists of many data centers filled with racks of computers. In a network topology, 
	leaves represent data nodes (computers) and inner nodes represent switches/routers that manage traffic in/out of data centers or racks."}.
	Per capire meglio, cercando nel web, ci si imbatte nella documentazione di 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/client/EnsemblePlacementPolicy.html}{EnsemblePlacementPolicy} 
	che contiene una spiegazione più dettagliata della "Network Topology": 
	\textit{"The network topology is presenting a cluster of bookies in a tree hierarchical structure. 
	For example, a bookie cluster may be consists of many data centers (aka regions) filled with racks of machines. 
	In this tree structure, leaves represent bookies and inner nodes represent switches/routes that manage traffic in/out of regions or racks.
	For example, there are 3 bookies in region `A`. They are `bk1`, `bk2` and `bk3`. And their network locations are /region-a/rack-1/bk1, 
	/region-a/rack-1/bk2 and /region-a/rack-2/bk3."} e rende tutto più chiaro (si veda anche la documentazione di \href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/Node.html}{Node}).
	Quindi, concettualmente si ha una rete strutturata ad albero.
	Un nodo foglia non può avere come parent il nodo ROOT, all'atto pratico questo significa che il bookie server deve essere necessariamente
	collocato in un rack/datacenter/\dots (collegato quindi a un router che rappresenti questo rack/datacenter/\dots), inserire un nodo tipo
	\textit{"/bookie-1"} (\underline{invalido}: essendo bookie$_1$ il server bookie/nodo foglia) non è consentito. 
	Inserire invece \textit{"/rack-1/bookie-1"} va bene (\underline{valido}), cosi come \textit{"/datacenter-1/
	rack-1/bookie-1"} (\underline{invalido}) e cosi via\dots Una volta stabilita l'altezza dell'albero (inserendo
	il primo ramo), non potranno essere inserite altre foglie ad altezza diversa.

	\subsubsection{Prima iterazione}
	Si decide di testare i metodi 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html#add(org.apache.bookkeeper.net.Node)}{add} e 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html#remove(org.apache.bookkeeper.net.Node)}{remove}
	di \href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html}{NetworkTopologyImpl} 
	perchè sono ritenuti i più importanti in quanto permettono di manipolare la topologia di rete aggiungendo e togliendo nodi.
	
	\textbf{Per il metodo add}: in tabella 
	\ref{\gettablelabel{ceq}{add}{NetworkTopologyImpl}{1}{\bookkeeper}}
	le classi d'equivalenza sono state scelte sulla base delle considerazioni fatte fino al paragrafo
	precedente sulla topologia di rete imposta da \bookkeeper\;(in particolare, in merito alla validità/non
	validità dei path dei nodes). In Java, qualsiasi riferimento ad
	un'oggetto può assumere valore null (tranne per i tipi primitivi), 
	che sarà quindi un valore da tenere quasi sempre in 
	considerazione dato che per alcuni metodi può avere un certo significato e/o conseguenze 
	sull'esecuzione. La tabella \ref{\gettablelabel{bv}{add}{NetworkTopologyImpl}{1}
	{\bookkeeper}} specifica i valori al bordo (la notazione \textit{Node("path")} presente in tabella indica
	istanze di nodi che puntano a quel path): in questo caso i nodi con path (non) valido, che (non) 
	passano il check di \underline{validazione} di NetworkTopologyImpl, sono molteplici, ma il valore al 
	bordo viene scelto per semplicità del percorso. 
	La tabella \ref{\gettablelabel{testc}{add}{NetworkTopologyImpl}{1}{\bookkeeper}}. 
	In tabella sono anche presentati
	gli esiti attesi con la motivazione - se l'esito atteso è:
	\begin{itemize}
		\item \textit{Nessuna variazione rispetto alla topologia attuale}: ci si aspetta che la 
		topologia prima e dopo l'esecuzione del metodo del SUT rimanga inalterata - nel nostro caso, 
		che la add avviene in una topologia di rete vuota, dopo l'esecuzione di add, ci si aspetta che 
		siano presenti 0 "racks" e 0 "leaves" (bookies) e il metodo del SUT che deve restituire il 
		riferimento al nodo in base al path cercato (\textit{"getNode"}) deve restituire null o eventualmente
		un nodo che non sia uguale a quello che si è tentato di inserire (spiegazione in fondo all'estensione
		dei casi di test del metodo add, seconda iterazione)
		\item \textit{Nessuna eccezione lanciata}: una eventuale eccezione (che sia checked o unchecked)
		inaspettata causa fallimento immediato dell'esecuzione del test.
		\item \textit{IllegalArgumentException lanciata}: mediante l'uso di \textit{assertThrows} di
		JUnit, ci si aspetta il lancio di una particolare eccezione da parte del metodo del SUT. Il
		non-lancio causa il fallimento immediato dell'asserzione e quindi dell'esecuzione del test.
		\item \textit{Aggiunta con successo del nodo alla rete}: sempre considerando che partiamo
		da una topologia di rete vuota - si verifica che siano presenti, dopo l'esecuzione del metodo
		del SUT, 1 "rack" e 1 "leave" (bookie), in più il metodo \textit{getNode} del SUT deve 
		restituire una reference all'oggetto che sia uguale a quella del nodo passato ad add.
	\end{itemize}
	
	Nella generazione dei casi di test è stato seguito un approccio unidimensionale.
	
	E' stato aggiunto un caso di test in più rispetto al boundary value della classe d'equivalenza di
	\{nodo con path valido\} al fine di testare inserimento del nodo ad un altezza diversa.
	
	Le condizioni di "nessuna variazione" e "IllegalArgumentException lanciata" vengono usate insieme
	in un caso: vengono verificate entrambe.	
	
	Nell'input, dove vengono specificati i parametri passati, viene usato il metodo buildNode che è:
	
	\textit{ BookieNode buildNode(String netLoc, String bookie) \{ return new
	BookieNode(BookieId.parse(bookie), netLoc); \} }
	
	In figura \ref{\getpicturelabel{bk/code-1-add-NetworkTopologyImpl-1}} è riportata l'implementazione del
	test parametrizzato.
	
	\textbf{Per il metodo remove}: in tabella \ref{\gettablelabel{ceq}{remove}{NetworkTopologyImpl}{1}
	{\bookkeeper}}, le classi d'equivalenza sono state scelte pensando al fatto che un nodo per essere
	rimosso deve essere presente (è importante la verifica della presenza del nodo), non è quindi tanto 
	importante se il nodo passato abbia un path valido
	o meno - nella peggiore delle situazioni il nodo non viene trovato anche se il path è invalido (add 
	effettua validazione - se fallisce, il nodo non verrà inserito) e quindi non c'è nessuna 
	eliminazione.
	In tabella \ref{\gettablelabel{bv}{remove}{NetworkTopologyImpl}{1}{\bookkeeper}} sono stati scelti i valori al
	bordo con lo stesso criterio di add.
	La tabella \ref{\gettablelabel{testc}{remove}{NetworkTopologyImpl}{1}{\bookkeeper}} specifica i casi di test:
	le condizioni di esito atteso sono simili. Per eseguire il secondo test case, è stato necessario
	prima inserire nel SUT il nodo da rimuovere. L'esito atteso \textit{"rimozione con successo
	del nodo dalla rete"} prevede la verifica che dopo l'add sia presente nella rete 1 rack e 1 leave 
	(getNode sul path deve restituire come riferimento lo stesso oggetto Node passato ad add)
	quindi, dopo la delete, in rete devono esserci 0 rack, 0 leave e getNode sul path deve restiutire 
	null. Il codice del test case è riportato in figura \ref{\getpicturelabel{bk/code-1-remove-NetworkTopologyImpl-1}}
	e \ref{\getpicturelabel{bk/code-2-remove-NetworkTopologyImpl-1}}. Anche in questo caso, per la
	generazione dei test case è stato seguito l'approccio unidimensionale.
	
	Prima dell'esecuzione del metodo di add o remove (a seconda del metodo sottto test), ci si accerta 	
	che la topologia contenga un nodo o sia vuota (a seconda del test case da eseguire), come indicato
	dagli esiti attesi (es. \textit{"...ci si aspetta di partire da una topologia di rete vuota"}, 
	oppure \textit{"rimozione di un nodo effettivamente presente nella rete..."})
		
	Nella figura \ref{\getpicturelabel{bk/controlflow-NetworkTopologyImpl-1}} sono riportate la
	statement coverage e la branch coverage di tutta la classe NetworkTopologyImpl: in particolare,
	in figura \ref{\getpicturelabel{bk/controlflow-add-NetworkTopologyImpl-1}} per il metodo add e in
	figura \ref{\getpicturelabel{bk/controlflow-remove-NetworkTopologyImpl-1}} per il metodo remove.
	
	In figura \ref{\getpicturelabel{bk/mutation-NetworkTopologyImpl-1}} è riportato un summary degli
	score sulla mutazione dell'intera classe: in figura \ref{\getpicturelabel{bk/mutation-add-NetworkTopologyImpl-1}} 
	e \ref{\getpicturelabel{bk/mutation-remove-NetworkTopologyImpl-1}} vengono
	specificate le righe nelle quali PITest ha eseguito delle modifiche (mutanti) e quali di queste 
	modifiche sono state rilevate (killed, in verde) e quali no (in rosso). Nella caption viene 
	riportato
	il numero di mutanti killed su numero di mutanti totali. Bisogna considerare che se la riga è rossa
	e il numero riportato a sinistra sul numero di mutanti applicati alla riga è $>$ 1, allora bisogna
	controllare bene perchè se almeno uno è sopravvissuto, la riga diventa rossa (non andremmo a contare
	potenziali mutanti killed).
	
	In figura \ref{\getpicturelabel{bk/dataflow-add-NetworkTopologyImpl-1}} e 
	\ref{\getpicturelabel{bk/dataflow-remove-NetworkTopologyImpl-1}} 
	è riportata in dettaglio la data flow coverage per i metodi add e remove.
	
	\subsubsection{Seconda iterazione}
	In generale, osserviamo come sia la statement coverage (70\%), la data flow coverage (24 def-use 
	coperte su 32 totali) e il mutation
	score (6 mut. killed su 8 totali) del metodo remove siano molto migliori dei rispettivi del metodo
	add (52\%, 30 def-use coperte su 58 totali, 8 mut. killed su 14 totali).
	
	I test sul metodo add eseguiti fino ad ora non hanno tenuto conto
	di ulteriori situazioni che il metodo deve gestire - sono stati eseguiti test case su una rete
	non popolata e che non ha quindi permesso la verifica dell'esito di inserimenti in ulteriori 
	casistiche, importanti e decisamente più realistiche 
	(es. che succede se il nodo che si prova a inserire è già nella rete?). Per il metodo add si
	progettano altri test case, anche allo scopo di migliorare i criteri di adequacy e il mutation score.
	
	Per quanto riguarda il metodo remove, le metriche sono adeguate e si decide di non proseguire 
	con un ulteriore iterazione di stesura dei test case: i casi di utilizzo di remove di maggior interesse
	sono stati coperti dalla test suite.
	
	Data l'importanza della classe, si decide di testare anche i metodi 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html#getDistance(org.apache.bookkeeper.net.Node,org.apache.bookkeeper.net.Node)}
	{getDistance},
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html#pseudoSortByDistance(org.apache.bookkeeper.net.Node,org.apache.bookkeeper.net.Node[])}
	{pseudoSortByDistance}
	- la scelta è dettata dal fatto che \bookkeeper\;è un sistema distribuito e quindi i metodi in questione svolgono un ruolo cruciale
	nel cercare, ad esempio, un bookie a distanza minima che rispetti certi criteri per replicare le entries - se il metodo pseudoSortByDistance
	funziona erroneamente si avrà un peggioramento delle prestazioni (la topologia rispecchia la distanza fisica tra i bookies - risultati errati di pseudoSortByDistance corrispondono a diminuzione del rate di trasferimento dati).
	
	\textbf{Estensione casi di test metodo add}: osserviamo dalla 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/net/NetworkTopologyImpl.html#add(org.apache.bookkeeper.net.Node)}
	{documentazione di add}
	che il metodo lancia IllegalArgumentException se il nodo da inserire non è una foglia, oppure si tenta
	di rendere una foglia esistente un parent ("appendendogli" una foglia) - per verificare che il metodo
	in queste condizioni abbia il comportamento atteso, bisogna estendere i casi di test: add deve validare il 
	nodo da inserire per la topologia di rete esistente - bisogna \underline{popolare la rete} prima di eseguire i test case. 
	E' un requisito di \bookkeeper\; che l'albero abbia tutti i rami alla stessa altezza.
	Che succede inoltre, se si prova ad inserire nodi con path già esistenti?
	\textit{Nella prima iterazione è stato possibile identificare un nodo con path non valido perchè per la topologia
	di rete "enforced" da \bookkeeper\; alla root non possono essere collegate delle foglie (prescinde l'albero
	di rete attuale)}
	
	\textit{Le tabelle per add e remove referenziate in questa seconda iterazione sono aggiuntive (non includono anche,
	ad esempio, le classi d'equivalenza o i test case generati dell'iterazione precedente, ma andranno considerate
	entrambe le tabelle per i profili operazionali e stima della reliability, a mo di unione tra set).}
	
	Prima dell'esecuzione dei test, viene generata una topologia di rete con altezza 3 (es. /dc-1/rack-1/bookie-1 
	è un leaf node della rete strutturata)
	
	In tabella \ref{\gettablelabel{ceq}{add}{NetworkTopologyImpl}{2}{\bookkeeper}} vengono specificate le
	classi d'equivalenza. Sono sufficienti queste 4 classi in quanto sufficienti a partizionare il dominio -
	il metodo non "capisce" la differenza tra /dc-1/rack-1 e /dc-1/bookie-1: se l'altezza del nodo da inserire
	è inferiore rispetto all'altezza dell'albero attuale, allora a prescindere il nodo non sarà una foglia, sia
	che si chiami "rack-1" che "bookie-1". Stessa cosa vale per l'inserimento di un nodo ad altezza superiore -
	può darsi che si tenti di rendere parent una foglia già esistente o di creare una nuova foglia ma ad altezza
	superiore. I boundary values in tabella \ref{\gettablelabel{bv}{add}{NetworkTopologyImpl}{2}{\bookkeeper}}
	sono stati generati per semplicità (es. non ha senso inserire un nodo ad altezza superiore che ha 10 livelli). In tabella \ref{\gettablelabel{testc}{add}{NetworkTopologyImpl}{2}{\bookkeeper}} sono presenti i test
	case generati. L'utilizzo di NodeBase è necessario perchè il metodo ausiliario buildNode usa il costruttore di
	BookieNode che a sua volta necessita di BookieId.parse che alla presenza di id del bookie non validi, lancia
	un'eccezione e non permette di proseguire col test del SUT (es. buildNode("/dc-2","") risulterebbe in eccezione per id del bookie non valido, ma è necessario per testare inserimento di inner node/router).
	
	Seguiamo anche qui un approccio unidimensionale alla generazione dei casi di test, e i significati
	degli esiti attesi sono identici a quelli descritti per add nell'iterazione precedente (ovviamente,
	relativamente alla "popolazione" della rete: se ad esempio si aggiunge un nodo, allora si verifica che
	vi siano prima $k$ nodi, poi, se ci si aspetta successo dell'inserimento, $k+1$ nodi)
	
	La motivazione per cui ci si aspetta che getNode, nel caso in cui l'inserimento fallisca, debba restituire
	null oppure un riferimento a un nodo diverso da quello di cui si è tentato l'inserimento è che getNode
	può restituire riferimenti a nodi anche non-foglia: se in una topologia ho un Node("/rack-1/bookie-1") allora
	avrò anche un nodo interno Node("/rack-1"): getNode sarà in grado di restituire la reference all'oggetto
	in questione. Se si prova a creare un \underline{nuovo} oggetto Node("/rack-1") (e quindi il suo inserimento),
	 e poi si tenta di effettuare
	l'asserzione che getNode("/rack-1") sia null, allora questa fallirà perchè un nodo con path "/rack-1" è
	effettiamente presente in rete, e ne verrà restituita la reference (ma ricordiamo, diversa da quella dell'
	oggetto di cui si è tentato l'inserimento). Nei test di add della prima iterazione, quest'aspetto è 
	indifferente, dato che la topologia è vuota.
	
	\textbf{Per il metodo getDistance}: In tabella 
	\ref{\gettablelabel{ceq}{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	sono presenti le classi d'equivalenza individuate, in tabella 
	\ref{\gettablelabel{bv}{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	i boundary values, 
	\ref{\gettablelabel{testc}{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	i test case generati.
	Le classi d'equivalenza sono state generate pensando agli utilizzi di
	getDistance e la sua gestione di parametri incorretti (un utilizzatore
	potrebbe per errore passare una reference null o costruire un nodo non
	appartenente alla rete e infatti è stato documentato come
	si comporta il metodo in quest'ultimo caso, quindi va verificato per 
	assicurarsi un corretto reporting all'utente). 
	I boundary values sono generati a partire da una
	rete prepopolata sulla quale eseguire il metodo per testarlo.
	Data la possibilità che \bookkeeper\; offre di gestire una rete gerarchica,
	potenzialmente su scala geografica, si è preferito optare per una rete 
	abbastanza alta da ricoprire questo caso di utilizzo (si pensi a grandi
	multinazionali).
	Per quanto riguarda i test case generati, è stato usato un approccio 
	multidimensionale e la differenza tra getNode e buildNode negli input, è
	che getNode viene usato sulla rete prepopolata per ottenere il riferimento
	al nodo di interesse, buildNode è un metodo statico che costruisce un nuovo
	nodo. Quando è presente buildNode, il nodo con quel path non è in rete (
	getNode restituirebbe null). Quello che è realmente di interesse è la distanza
	tra i bookies che interagiscono tra loro, e non tra i router, quindi,
	calcoliamo la distanza tra \textit{/europe/it/.../bookie-1} e 
	\textit{/europe/de/.../bookie-6} e cosi via\dots L'algoritmo per il calcolo 
	della distanza è descritto nella documentazione di getDistance: basta 
	individuare il common ancestor di entrambi i nodi e sommare il numero di hop 
	per arrivare da un nodo a un altro: per \textit{/italy/rack-1/bookie-1} e 
	\textit{/italy/rack-1/bookie-2} ad esempio, la distanza tra i due bookie è 2 
	perchè da \textit{bookie-1} \underline{vado} in \textit{rack-1} e poi da 
	\textit{rack-1} \underline{vado} in \textit{bookie-2}, non c'è bisogno di 
	effettuare ulteriori salti, essendo collegati allo stesso router/rack
	(tralasciando definizioni specifiche di rete). 
	Sulla base di questo algoritmo sono stati elaborati i valori di ritorno
	dei casi di test (dei nodi appartenenti alla rete). Negli altri casi,
	è stata seguita la documentazione dove possibile (ritorno di
	Integer.MAX\_VALUE) e sono state effettuate assunzioni dove non 
	specificato (gestione di null references).
	Gli esiti attesi sono auto-esplicativi (ritorno valore 0 e nessuna eccezione
	lanciata indicano una gestione passiva da parte del metodo di argomenti attuali non validi.)
	Purtroppo i test dal numero 2 al numero 8 falliscono: il metodo non gestisce
	le null reference come ci si aspetterebbe (viene lanciata
	NullPointerException) e non ritorna MAX\_VALUE se uno dei nodi non appartiene
	alla rete. Però c'è da precisare che nonostante nella reliability calcolata
	si considerino tutte le combinazioni dei valori usati come input in modo
	uniforme, è molto poco probabile che le combinazioni dei test falliti vengano
	effettivamente usate, il metodo, nella sua "configurazione" di utilizzo più
	probabile (entrambi i nodi appartenenti alla rete) passa tutti i test.
	
	\textbf{Per il metodo pseudoSortByDistance}: In tabella 
	\ref{\gettablelabel{ceq}{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	sono presenti le classi d'equivalenza individuate, in tabella 
	\ref{\gettablelabel{bv}{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	i boundary values, 
	\ref{\gettablelabel{testc}{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	i test case generati.
	Anche qui è stato usato un approccio multidimensionale alla generazione dei
	test case e sta volta, non è stato inclusa la classe d'equivalenza relativa
	a nodi non presenti in rete (sia per il reader che l'array di nodi da
	ordinare) in quanto di bassa probabilità di utilizzo, e allo scopo di ridurre
	il numero di test della test suite.
	La classe aggiuntiva che riguarda un array di nodi con almeno un nodo che sia
	null è utile perchè sta volta non è il riferimento all'array ad essere null,
	ma un suo elemento (la gestione non viene comunque specificata dalla
	documentazione) e questo può compromettere l'esecuzione del metodo (per
	dimenticanza o assunzione del programmatore è più facile pensare che se
	il riferimento all'array non è null allora nemmeno i suoi elementi lo saranno,
	portando a runtime errors nel caso in cui almeno un elemento sia null).
	Il sorting avviene sempre sui nodi della topologia prepopolata (uguale a quella
	del metodo getDistance). Per quanto riguarda la notazione, nei test case
	Array$<$Node$>$[ \dots ] è analogo a new Node[] \{ \dots \} in Java.
	L'esito atteso "Il metodo termina l'esecuzione nesuna eccezione lanciata"
	significa che l'esecuzione del metodo è praticamente una noop (ad esempio
	se il metodo termina e l'array passato era null, non posso verificare alcun
	ordinamento, 
	ci si aspetta solamente terminazione senza lancio di eccezioni). 
	L'implementazione del test è più complessa del normale perchè
	non basta osservare il sorting basato sulla distanza rispetto al reader:
	se il reader ha più di un nodo alla stessa distanza, questi ultimi (supponiamo ) due nodi possono essere posti da pseudoSortByDistance prima rispetto all'altro
	o viceversa - dato che l'implementazione di pseudoSortByDistance nel corso del tempo può cambiare,
	bisogna considerare esatto l'ordinamento anche se i due nodi alla stessa
	distanza sono scambiati rispetto a quanto previsto da noi (es. 
	se il nodo reader è \textit{/rack-1/bookie-1} e l'array è composto da \textit{/rack-1/bookie-2} e \textit{/rack-1/bookie-3} allora sia bookie-3 che bookie-2 possono 
	trovarsi nell'array sortato prima rispetto all'altro, dato che entrambi sono
	alla stessa distanza rispetto a bookie-1.
	Il calcolo della distanza è uguale a
	quello di getDistance.
	
	I test falliti di questo metodo sono tutti quelli che hanno come nodes 
	un array null (NullPointerException) - questo rivela un non-proper-checking
	degli argomenti passati al metodo.
	
	Nelle figure \ref{\getpicturelabel{bk/controlflow-NetworkTopologyImpl-2}}, \ref{\getpicturelabel{bk/controlflow-add-NetworkTopologyImpl-2}}, \ref{\getpicturelabel{bk/controlflow-getDistance-NetworkTopologyImpl-2}} e \ref{\getpicturelabel{bk/controlflow-pseudoSortByDistance-NetworkTopologyImpl-2}} si hanno la stmt. coverage e branch coverage che è aumentata sia per l'intera classe(50\%,51\%) che per il metodo add(71\%,81\%), come da obiettivo.
	Per getDistance si ottiene 69\%,60\% e pseudoSortByDistance 93\%,83\%.
	Nelle figure \ref{\getpicturelabel{bk/mutation-NetworkTopologyImpl-2}}, 
	\ref{\getpicturelabel{bk/mutation-add-NetworkTopologyImpl-2}},
	\ref{\getpicturelabel{bk/mutation-getDistance-NetworkTopologyImpl-2}},
	\ref{\getpicturelabel{bk/mutation-pseudoSortByDistance-NetworkTopologyImpl-2}} si ha il report di PIT per
	le mutazioni: per l'intera classe si ha un'incremento sia della mutation coverage, sia del test strength,
	mentre per add si ottiene un notevole incremento di mutanti killed: 13 su 14 totali.
	Per getDistance si ottengono invece 14 mut. killed su 23 totali (includendo sia quelli survived che quelli
	NO\_COVERAGE, i test non hanno coperto quella linea di codice per cui è stato creato il mutante), mentre per
	pseudoSortByDistance 13 mut. killed su 20 totali.
	Nella figura \ref{\getpicturelabel{bk/dataflow-add-NetworkTopologyImpl-2}} si ha la data flow coverage per add,
	in \ref{\getpicturelabel{bk/dataflow-getDistance-1-NetworkTopologyImpl-2}} per getDistance,
	in \ref{\getpicturelabel{bk/dataflow-getDistance-2-NetworkTopologyImpl-2}} per getDistance,
	in \ref{\getpicturelabel{bk/dataflow-pseudoSortByDistance-1-NetworkTopologyImpl-2}} per pseudoSortByDistance,
	in \ref{\getpicturelabel{bk/dataflow-pseudoSortByDistance-2-NetworkTopologyImpl-2}} per pseudoSortByDistance.
	Si hanno più report per la stessa classe quando vengono effettuati i test sulla stessa classe da diverse classi
	di test, quindi, per ottenere la copertura dataflow complessiva, bisogna sovrapporre i report. Viene fatto 
	per add (è avvenuta un estensione dei test su un'altra classe di test, quindi va contata complessivamente anche
	la classe dell'iterazione precedente), getDistance e pseudoSortByDistance.
	Ne risulta che il dataflow coverage è incrementato per add: 48 coppie coperte su 58 totali, per
	getDistance 42 coperte su 101 per pseudoSortByDistance 55 su 101. Nel resto delle figure, dalla
	\ref{\getpicturelabel{bk/code-1-add-NetworkTopologyImpl-2}} alla 
	\ref{\getpicturelabel{bk/code-5-pseudoSortByDistance-NetworkTopologyImpl-2}} viene riportato il codice di test.
	
	In tabella \ref{\getreltablelabel{NetworkTopologyImpl}{\bookkeeper}} è
	presente la reliabilty dei metodi testati. I test falliti vengono disattivati
	per terminare la build e ottenere informazioni sull'adeguatezza dei test e
	sulle mutazioni.

	\subsection{org.apache.bookkeeper.bookie.BufferedChannel}
	Dalla 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedChannel.html}
	{documentazione}: \textit{"Provides a buffering layer in front of a FileChannel"}.
	In altre parole, evita che un file venga scritto continuamente, allocando un buffer in memoria e aspettando
	che scrittura dopo scrittura, quest'ultimo venga riempito per poi scrivere sul file (tramite metodi di 
	FileChannel). Questa classe è stata scelta perchè cruciale ai fini di migliorare le prestazioni di \bookkeeper.
	Il costruttore invocato è 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedChannel.html#\%3Cinit\%3E(io.netty.buffer.ByteBufAllocator,java.nio.channels.FileChannel,int)}
	{quello a 3 argomenti}.
	
	%e il FileChannel è soggetto a mocking per evitare di avere
	%a che fare con il filesystem, lettura di file, setup e cleanup dopo ogni test.
	
	\subsubsection{Prima iterazione}
	Testiamo i metodi 
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedChannel.html#read(io.netty.buffer.ByteBuf,long,int)}
	{read} e
	\href{https://bookkeeper.apache.org/docs/latest/api/javadoc/org/apache/bookkeeper/bookie/BufferedChannel.html#write(io.netty.buffer.ByteBuf)}
	{write}
	dato che sono fondamentali per scrivere e leggere dal buffer.
	
	\newpage
	\section{Link ai repository}
	\begin{itemize}
		\item BookKeeper: \url{https://github.com/StefanoBelli/bookkeeper}
		\begin{itemize}
			\item test localizzati in \textit{bookkeeper-server/src/test/java/\dots}
			\item CI (build$\;\rightarrow\;$test$\;\rightarrow\;$adequacy$\;\rightarrow\;$
			mutation$\;\rightarrow\;$report-packaging$\;\rightarrow\;$package-upload): 
			\url{https://github.com/StefanoBelli/bookkeeper/actions/workflows/ste-ci.yml} 
			(tra gli artifact c'è adequacy-reports.zip per ogni build triggerata)
		\end{itemize}
		\item Storm: \url{https://github.com/StefanoBelli/storm}
		\begin{itemize}
			\item test localizzati in \textit{storm-client/test/jvm/\dots}
			\item CI (build$\;\rightarrow\;$test$\;\rightarrow\;$adequacy$\;\rightarrow\;$
			mutation$\;\rightarrow\;$report-packaging$\;\rightarrow\;$package-upload): 
			\url{https://github.com/StefanoBelli/storm/actions/workflows/ste-ci.yml}
			(tra gli artifact c'è adequacy-reports.zip per ogni build triggerata)
		\end{itemize}
	\end{itemize}
	
	\newpage
	\section{Tabelle, figure e code listings}
	
	%
	% Iter: 1, Class: NetworkTopologyImpl, Project: Bookkeeper
	%
	
	\ceqtable{add}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{node} & \tcell{\ceq{null} \\ \ceq{nodo con path invalido} \\ \ceq{nodo con path valido} }
		\newtrow
	}
	
	\bvtable{add}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{node} & \tcell{\ceq{null}} & \tcell{null}
		\newtrow
			\tcell{node} & \tcell{\ceq{nodo con path invalido}} & \tcell{Node("/bookie-1")}
		\newtrow
			\tcell{node} & \tcell{\ceq{nodo con path valido}} & \tcell{Node("/rack-1/bookie-1")}
		\newtrow
	}
	
	\testctable{add}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{null} & \tcell{Nessuna variazione rispetto\\ alla topologia attuale,\\ nessuna 
			eccezione lanciata} & \tcell{Specifica della documentazione:\\ si prevede la gestione del 
			caso\\ in cui node sia null}
		\newtrow
			\tcell{buildNode("/rack-1","bookie-1")} & \tcell{Aggiunta con successo del nodo\\ alla rete} 
			& \tcell{Il nodo è una foglia (un server bk)\\ raggiungibile da /rack-1}
		\newtrow
			\tcell{buildNode("/","bookie-2")} & \tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\IllegalArgumentException viene\\ lanciata} & 
			\tcell{Il nodo è una foglia (un server bk)\\ ma non è raggiunta da un rack \\
			(è un requisito che il nodo foglia\\ non abbia come parent la root) }
		\newtrow
			\tcell{buildNode("/dc-1/rack-1", "bookie-3")} & \tcell{Aggiunta con successo del nodo\\ alla 
			rete} & \tcell{Il nodo è una foglia (un server bk)\\ raggiungibile da /dc-1/rack-1}
		\newtrow
	}
	
	\ceqtable{remove}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{node} & \tcell{\ceq{null}, \\ \ceq{nodo con path non presente in rete},\\ \ceq{nodo 
			con path presente in rete}}
		\newtrow
	}
	
	\pagebreak
	
	\bvtable{remove}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{node} & \tcell{\ceq{null}} & \tcell{null} 
		\newtrow
			\tcell{node} & \tcell{\ceq{nodo con path non presente in rete}} & \tcell{Node("/rack-1/bookie-1")}
		\newtrow
			\tcell{node} & \tcell{\ceq{nodo con path presente in rete}} & \tcell{Node("/rack-1/bookie-2")}
		\newtrow
	}
	
	\testctable{remove}{NetworkTopologyImpl}{1}{\bookkeeper}{
			\tcell{null} & \tcell{Nessuna variazione rispetto\\ alla topologia attuale,\\ nessuna 
			eccezione lanciata} & \tcell{Specifica della documentazione:\\ si prevede la gestione del 
			caso\\ in cui node sia null}
		\newtrow
			\tcell{buildNode("/rack-1","bookie-1")} & \tcell{Rimozione con successo del nodo\\ dalla rete} & \tcell{Il nodo è una foglia (un server bk)\\ raggiungibile da /rack-1\\ aggiunto in precedenza}
		\newtrow
			\tcell{buildNode("/rack-1","bookie-2")} & \tcell{Nessuna variazione rispetto\\ alla topologia attuale,\\ nessuna eccezione lanciata} & \tcell{Il nodo è una foglia (un server bk)\\ raggiungibile da /rack-1\\ MA NON aggiunto in precedenza}
		\newtrow
	}	
	
	\makepicture{17cm}{1.15cm}{bk/controlflow-NetworkTopologyImpl-1}
				{\classcfcovcaption{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-add-NetworkTopologyImpl-1}
				{\methodcfcovcaption{add}{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-remove-NetworkTopologyImpl-1}
				{\methodcfcovcaption{remove}{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{17cm}{1.5cm}{bk/mutation-NetworkTopologyImpl-1}
				{\mutclasscaption{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{17cm}{15cm}{bk/mutation-add-NetworkTopologyImpl-1}
				{\mutmethodcaption{add}{NetworkTopologyImpl}{1}{\bookkeeper}{8}{14}}
	
	\makepicture{17cm}{10cm}{bk/mutation-remove-NetworkTopologyImpl-1}
				{\mutmethodcaption{remove}{NetworkTopologyImpl}{1}{\bookkeeper}{6}{8}}
				
	\makepicture{13cm}{23cm}{bk/dataflow-add-NetworkTopologyImpl-1}
				{\alldfcovcaption{add}{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{13cm}{15cm}{bk/dataflow-remove-NetworkTopologyImpl-1}
				{\alldfcovcaption{remove}{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{17cm}{16cm}{bk/code-1-add-NetworkTopologyImpl-1}
				{Parametri e metodo: \finishcodecaption{add}{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{16cm}{10cm}{bk/code-1-remove-NetworkTopologyImpl-1}
				{Parametri e metodo: \finishcodecaption{remove}{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	\makepicture{16cm}{12cm}{bk/code-2-remove-NetworkTopologyImpl-1}
				{Metodi statici per evitare eccessiva duplicazione di codice di verifica:
				\finishcodecaption{remove}{NetworkTopologyImpl}{1}{\bookkeeper}}
				
	%
	% Iter: 2, Class: NetworkTopologyImpl, Project: Bookkeeper
	%
	
	\ceqtable{add}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{node} & \tcell{
									\ceq{nodo con path ad altezza inferiore risp. alla topologia attuale} \\
									\ceq{nodo con path ad altezza superiore risp. alla topologia attuale} \\
									\ceq{nodo con path già esistente} \\
									\ceq{nodo con path valido risp. alla topologia attuale(uguale altezza) e non esistente}
								}
		\newtrow
	}
	
	\bvtable{add}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{node} & 
			\tcell{\ceq{nodo con path ad altezza inferiore\\ risp. alla topologia attuale}} &
			\tcell{Node("/rack-1/bookie-1")}
		\newtrow
			\tcell{node} &
			\tcell{\ceq{nodo con path ad altezza superiore\\ risp. alla topologia attuale}} &
			\tcell{Node("/region-1/dc-1/rack-1/bookie-1")}
		\newtrow
			\tcell{node} &
			\tcell{\ceq{nodo con path già esistente}} &
			\tcell{Node("/dc-1/rack-1/bookie-1")}
		\newtrow
			\tcell{node} &
			\tcell{\ceq{nodo con path valido risp.\\ alla topologia attuale\\(uguale altezza) e non esistente}} &
			\tcell{Node("/dc-3/rack-4/bookie-7")}
		\newtrow
	}
	
	\testctable{add}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{buildNode("/rack-1","bookie-1")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\InvalidTopologyException viene\\ lanciata} &
			\tcell{La documentazione specifica\\lancio di eccezione
			se il nodo\\ inserito non è una foglia\\ (altezza inferiore,\\
			tentativo di aggiunta foglia)}
		\newtrow
			\tcell{NodeBase("/dc-2")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\InvalidTopologyException viene\\ lanciata} &
			\tcell{La documentazione specifica\\lancio di eccezione
			se il nodo\\ inserito non è una foglia\\ (altezza inferiore,\\
			tentativo di aggiunta di un router)}
		\newtrow
			\tcell{NodeBase("/dc-3/rack-2")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\InvalidTopologyException viene\\ lanciata} &
			\tcell{La documentazione specifica\\lancio di eccezione
			se il nodo\\ inserito non è una foglia\\ (altezza inferiore,\\
			tentativo di aggiunta di un router)}
		\newtrow
			\tcell{buildNode("/region-1/dc-1/rack-1",\\"bookie-1")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\InvalidTopologyException viene\\ lanciata} &
			\tcell{La documentazione specifica\\lancio di eccezione
			se il nodo\\ ha altezza maggiore rispetto\\
			all'albero attuale}
		\newtrow
			\tcell{buildNode("/dc-1/rack-1/bookie-1",\\"another-bookie")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\InvalidTopologyException viene\\ lanciata} &
			\tcell{La documentazione specifica\\ lancio di eccezione
			se il nodo\\ ha come parent una foglia\\ esistente
			(un bookie non è un router)}
		\newtrow
			\tcell{buildNode("/dc-1/rack-1","bookie-1")} &
			\tcell{Nessuna variazione rispetto \\ alla topologia 
			attuale, \\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\ nulla a riguardo
			dell'inserimento\\  di nodi già esistenti, ma è ragionevole\\
			aspettarsi che il nodo da inserire\\ venga ignorato, dato che\\
			è già presente}
		\newtrow
			\tcell{buildNode("/dc-3/rack-4","bookie-7")} &
			\tcell{Aggiunta con successo del nodo\\ alla rete} &
			\tcell{Il nodo ha altezza coerente\\ con la topologia attuale e\\ 
			non esiste attualmente \\(/dc-3/rack-4 già esistenti,\\ ma non bookie-7)}
		\newtrow
			\tcell{buildNode("/dc-3/rack-5","bookie-8")} &
			\tcell{Aggiunta con successo del nodo\\ alla rete} &
			\tcell{Il nodo ha altezza coerente\\ con la topologia attuale e\\ 
			non esiste attualmente \\(/dc-3 già esistente,\\ ma non rack-5/bookie-8)}
		\newtrow
			\tcell{buildNode("/dc-4/rack-6","bookie-9")} &
			\tcell{Aggiunta con successo del nodo\\ alla rete} &
			\tcell{Il nodo ha altezza coerente\\ con la topologia attuale e\\ 
			non esiste attualmente \\(/dc-4/rack-6/bookie-9 non esistono)}
		\newtrow
			\tcell{buildNode("/dc-4/rack-6","bookie-7")} &
			\tcell{Aggiunta con successo del nodo\\ alla rete} &
			\tcell{Il nodo ha altezza coerente\\ con la topologia attuale e\\ 
			non esiste attualmente \\(Esiste un altro "bookie-7"\\ 
			\underline{MA in un altro ramo} dell'albero)}
		\newtrow
	}
	
	\ceqtable{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{node1} &
			\tcell{
				\ceq{null}\\
				\ceq{nodo appartenente alla rete} \\
				\ceq{nodo non appartenente alla rete}}
		\newtrow
			\tcell{node2} &
			\tcell{
				\ceq{null}\\
				\ceq{nodo appartenente alla rete} \\
				\ceq{nodo non appartenente alla rete}}
		\newtrow
	}
	
	\bvtable{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{node1} &
			\tcell{\ceq{null}} &
			\tcell{null}
		\newtrow
			\tcell{node1} &
			\tcell{\ceq{nodo appartenente alla rete}} &
			\tcell{Node("/europe/it/lazio/frosinone/rack-1/bookie-1")}
		\newtrow
			\tcell{node1} &
			\tcell{\ceq{nodo non appartenente alla rete}} &
			\tcell{Node("/asia/ru/region-1/moscow/rack-2/bookie-2")}
		\newtrow
			\tcell{node2} &
			\tcell{\ceq{null}} &
			\tcell{null}
		\newtrow
			\tcell{node2} &
			\tcell{\ceq{nodo appartenente alla rete}} &
			\tcell{Node("/europe/it/lazio/frosinone/rack-1/bookie-1")}
		\newtrow
			\tcell{node2} &
			\tcell{\ceq{nodo non appartenente alla rete}} &
			\tcell{Node("/asia/ru/region-1/moscow/rack-2/bookie-2")}
		\newtrow
	}
	
	\testctable{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{
					null, null} &
			\tcell{Ritorno valore 0,\\nessuna eccezione sollevata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/frosinone/\\rack-1/bookie-1"),\\
					null} &
			\tcell{Ritorno valore 0,\\nessuna eccezione sollevata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado (nodo non-null\\ esistente)}
		\newtrow
			\tcell{
					buildNode("/asia/ru/region-1/\\moscow/rack-2/bookie-2"),\\
					null} &
			\tcell{Ritorno valore 0,\\nessuna eccezione sollevata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado (nodo non-null\\ non-esistente)}
		\newtrow
			\tcell{
					null,\\
					getNode("/europe/it/lazio/frosinone/\\rack-1/bookie-1")} &
			\tcell{Ritorno valore 0,\\nessuna eccezione sollevata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado (nodo non-null\\ esistente)}
		\newtrow
			\tcell{
					null,\\
					buildNode("/asia/ru/region-1/\\moscow/rack-2/bookie-2")} &
			\tcell{Ritorno valore 0,\\nessuna eccezione sollevata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado (nodo non-null\\ non-esistente)}
		\newtrow
			\tcell{
					buildNode("/asia/ru/region-1/\\moscow/rack-2/bookie-2"),\\
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1")} &
			\tcell{Ritorno valore Integer.MAX\_VALUE} &
			\tcell{Il primo nodo non esiste\\ e la documentazione specifica\\ il ritorno di Integer.MAX\_VALUE}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					buildNode("/asia/ru/region-1/\\moscow/rack-2/bookie-2")} &
			\tcell{Ritorno valore Integer.MAX\_VALUE} &
			\tcell{Il secondo nodo non esiste\\ e la documentazione specifica\\ il ritorno di Integer.MAX\_VALUE}
		\newtrow
			\tcell{
					buildNode("/asia/cn/region-1/\\beijing/rack-1/bookie-1"),\\
					buildNode("/asia/ru/region-1/\\moscow/rack-2/bookie-2")} &
			\tcell{Ritorno valore Integer.MAX\_VALUE} &
			\tcell{Entrambi i nodi non esistono\\ 
			e la documentazione specifica\\ il ritorno di Integer.MAX\_VALUE}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1")} &
			\tcell{Ritorno valore 0} &
			\tcell{Il nodo è presente in rete:\\ come da documentazione,\\ dist. tra lo stesso nodo è 0}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-2")} &
			\tcell{Ritorno valore 2} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/it/lazio/\\roma/rack-2/bookie-3")} &
			\tcell{Ritorno valore 4} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/it/lazio/\\frosinone/rack-1/bookie-4")} &
			\tcell{Ritorno valore 6} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/it/lombardia/\\milano/rack-1/bookie-5")} &
			\tcell{Ritorno valore 8} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/europe/de/region-1/\\berlino/rack-1/bookie-6")} &
			\tcell{Ritorno valore 10} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
			\tcell{
					getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					getNode("/america/us/california/\\paloalto/rack-2/bookie-7")} &
			\tcell{Ritorno valore 12} &
			\tcell{Entrambi i nodi sono presenti in rete\\(algoritmo calcolo distanza\\presente nella
				documentazione\\del metodo)}
		\newtrow
	}
	
	\ceqtable{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{reader} &
			\tcell{\ceq{null}\\\ceq{nodo presente in rete}}
		\newtrow
			\tcell{nodes} &
			\tcell{\ceq{null}\\\ceq{array con tutti i nodi al suo interno \\ 
			presenti in rete}\\\ceq{array con almeno un nodo\\al suo interno\\
			che sia null}}
		\newtrow
	}
	
	\bvtable{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{reader} & \tcell{\ceq{null}} & \tcell{null}
		\newtrow
			\tcell{reader} & \tcell{\ceq{nodo presente in rete}} & 
			\tcell{Node("/europe/it/lazio/roma/rack-1/bookie-1")}
		\newtrow
			\tcell{nodes} & \tcell{\ceq{null}} & \tcell{null}
		\newtrow
			\tcell{nodes} & \tcell{\ceq{array con tutti i nodi\\ al suo interno \\presenti in rete}} & 
			\tcell{Array$<$Node$>$[\\
					\;\;Node("/europe/it/lazio/roma/rack-1/bookie-1"),\\
					\;\;Node("/europe/it/lazio/roma/rack-1/bookie-2"),\\
					\;\;Node("/europe/it/lazio/roma/rack-2/bookie-3"),\\
					\;\;Node("/europe/it/lazio/frosinone/rack-3/bookie-4"),\\
					\;\;Node("/europe/it/lombardia/milano/rack-4/bookie-5"),\\
					\;\;Node("/europe/de/region-1/berlino/rack-5/bookie-6"),\\
					\;\;Node("/america/us/california/paloalto/rack-6/bookie-7")
					\\]}
		\newtrow
			\tcell{nodes} &
			\tcell{\ceq{array con almeno\\ un nodo al suo interno\\
			che sia null}} &
			\tcell{Array$<$Node$>$[\\\;\;null\\]}
		\newtrow
	}	
	
	\testctable{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{
			\tcell{getNode("/europe/it/lazio\\/roma/rack-1/bookie-1"),\\
				Array$<$Node$>$[\\
					\;\;getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\
					\;\;getNode("/europe/it/lazio/\\roma/rack-1/bookie-2"),\\
					\;\;getNode("/europe/it/lazio/\\roma/rack-2/bookie-3"),\\
					\;\;getNode("/europe/it/lazio/\\frosinone/rack-3/bookie-4"),\\
					\;\;getNode("/europe/it/lombardia/\\milano/rack-4/bookie-5"),\\
					\;\;getNode("/europe/de/region-1/\\berlino/rack-5/bookie-6"),\\
					\;\;getNode("/america/us/california/\\paloalto/rack-6/bookie-7")
					\\]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttaamente in base\\
			 alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/europe/it/lazio/\\roma/rack-1/bookie-2"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/europe/it/lazio/\\roma/rack-2/bookie-3"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/europe/it/lazio/\\frosinone/rack-3/bookie-4"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/europe/it/lombardia/\\milano/rack-4/bookie-5"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/europe/de/region-1/\\berlino/rack-5/bookie-6"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{getNode("/america/us/california/\\paloalto/rack-6/bookie-7"),\\
				Array$<$Node$>$[\\
					\;\;\dots \textit{nodi unsorted} \\ \textit{(rispetto al nodo reader)}
					\dots \\
				]} &
			\tcell{L'array passato (by reference) \\
			è stato ordinato correttamente in base\\
			alla distanza dal nodo reader} &
			\tcell{Tutti i nodi (reader e nell'array)\\ sono presenti in rete}
		\newtrow
			\tcell{null, null} &
			\tcell{Il metodo termina l'esecuzione\\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
			\tcell{null, Array$<$Node$>$[null]} &
			\tcell{Il metodo termina l'esecuzione\\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
			\tcell{null, \\Array$<$Node$>$[\\\;\;getNode("/europe/it/lazio/\\roma/rack-1/bookie-1")\\]} &
			\tcell{Il metodo termina l'esecuzione\\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
			\tcell{getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"), null} &
			\tcell{Il metodo termina l'esecuzione\\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
			\tcell{getNode("/europe/it/lazio/\\roma/rack-1/bookie-1"),\\ Array$<$Node$>$[null]} &
			\tcell{Il metodo termina l'esecuzione\\nessuna eccezione lanciata} &
			\tcell{La documentazione non specifica\\la gestione dei nodi null.\\
					Dato che altri metodi d'istanza\\gestiscono ref. null\\
					si assume che anche questo\\ ne sia in grado}
		\newtrow
	}
	
	\makepicture{17cm}{1.15cm}{bk/controlflow-NetworkTopologyImpl-2}
				{\classcfcovcaption{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-add-NetworkTopologyImpl-2}
				{\methodcfcovcaption{add}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-getDistance-NetworkTopologyImpl-2}
				{\methodcfcovcaption{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{0.75cm}{bk/controlflow-pseudoSortByDistance-NetworkTopologyImpl-2}
				{\methodcfcovcaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{1.5cm}{bk/mutation-NetworkTopologyImpl-2}
				{\mutclasscaption{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{13cm}{bk/mutation-add-NetworkTopologyImpl-2}
				{\mutmethodcaption{add}{NetworkTopologyImpl}{2}{\bookkeeper}{13}{14}}
	
	\makepicture{13cm}{10cm}{bk/mutation-getDistance-NetworkTopologyImpl-2}
				{\mutmethodcaption{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{14}{23}}
	
	\makepicture{13cm}{10cm}{bk/mutation-pseudoSortByDistance-NetworkTopologyImpl-2}
				{\mutmethodcaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}{13}{20}}
				
	\makepicture{13cm}{24cm}{bk/dataflow-add-NetworkTopologyImpl-2}
				{\alldfcovcaption{add}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{12cm}{24cm}{bk/dataflow-getDistance-1-NetworkTopologyImpl-2}
				{\alldfcovcaption{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{13cm}{24cm}{bk/dataflow-getDistance-2-NetworkTopologyImpl-2}
				{\alldfcovcaption{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{13cm}{24cm}{bk/dataflow-pseudoSortByDistance-1-NetworkTopologyImpl-2}
				{\alldfcovcaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{13cm}{24cm}{bk/dataflow-pseudoSortByDistance-2-NetworkTopologyImpl-2}
				{\alldfcovcaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{7cm}{bk/code-1-add-NetworkTopologyImpl-2}
				{Parametri: \finishcodecaption{add}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{16cm}{12cm}{bk/code-2-add-NetworkTopologyImpl-2}
				{Test code: \finishcodecaption{add}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{16cm}{12cm}{bk/code-3-add-NetworkTopologyImpl-2}
				{Popolazione della rete: \finishcodecaption{add}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{16cm}{bk/code-1-getDistance-NetworkTopologyImpl-2}
				{Parametri e test code (argomenti "non comuni", commentati test falliti):
				\finishcodecaption{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{16cm}{bk/code-2-getDistance-NetworkTopologyImpl-2}
				{Builder dei nodi (relativi alla figura 
				\ref{\getpicturelabel{bk/code-1-getDistance-NetworkTopologyImpl-2}}): 
				\finishcodecaption{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	
	\makepicture{17cm}{10cm}{bk/code-3-getDistance-NetworkTopologyImpl-2}
				{Parametri e test code (argomenti "comuni"): 
				\finishcodecaption{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{13cm}{bk/code-1-pseudoSortByDistance-NetworkTopologyImpl-2}
				{Argomenti dei test da eseguire (in totale 7, argomenti "comuni"), gli interi
				specificati nella coppia indicano la distanza dal nodo a cui corrispondono al nodo reader
				(quello sullo stesso livello di indent di Arrays.asList): 
				\finishcodecaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{7.5cm}{bk/code-2-pseudoSortByDistance-NetworkTopologyImpl-2}
				{Test code (argomenti "comuni"): 
				\finishcodecaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{5cm}{bk/code-6-pseudoSortByDistance-NetworkTopologyImpl-2}
				{Sorting basato sulle distanze specificate in figura 
				\ref{\getpicturelabel{bk/code-1-pseudoSortByDistance-NetworkTopologyImpl-2}}, 
				l'array qui ordinato verrà confrontato con quanto risulterà dal metodo testato: 
				\finishcodecaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{16cm}{bk/code-3-pseudoSortByDistance-NetworkTopologyImpl-2}
				{Metodo di check dell'ordinamento (argomenti "comuni"): 
				\finishcodecaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
	
	\makepicture{10cm}{7cm}{bk/code-4-pseudoSortByDistance-NetworkTopologyImpl-2}
				{Classe utility per indicare nodi e distanze "expected" (argomenti "comuni"): 
				\finishcodecaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
				
	\makepicture{17cm}{12cm}{bk/code-5-pseudoSortByDistance-NetworkTopologyImpl-2}
				{Parametri e test code (argomenti "non comuni"): 
				\finishcodecaption{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}
			
	\newpage
	\reltable{NetworkTopologyImpl}{\bookkeeper}{
			\tcell{add} &
			\tcell{$14$} &
			\tcell{$14$} &
			\tcell{$0$} &
			\tcell{
					tabella $\ref{\gettablelabel{testc}{add}{NetworkTopologyImpl}{1}{\bookkeeper}}$,
					tabella $\ref{\gettablelabel{testc}{add}{NetworkTopologyImpl}{2}{\bookkeeper}}$} &
			\tcell{\unifdist{0.07}} &
			\tcell{$1$}
		\newtrow	
			\tcell{remove} &
			\tcell{$3$} &
			\tcell{$3$} &
			\tcell{$0$} &
			\tcell{
					tabella $\ref{\gettablelabel{testc}{remove}{NetworkTopologyImpl}{1}{\bookkeeper}}$} &
			\tcell{\unifdist{0.33}} &
			\tcell{$1$}
		\newtrow
			\tcell{getDistance} &
			\tcell{$15$} &
			\tcell{$8$} &
			\tcell{$7$} &
			\tcell{
					tabella $\ref{\gettablelabel{testc}{getDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}$} &
			\tcell{\unifdist{0.067}} &
			\tcell{$0.531$}
		\newtrow
			\tcell{pseudoSort\\ByDistance} &
			\tcell{$12$} &
			\tcell{$10$} &
			\tcell{$2$} &
			\tcell{
					tabella $\ref{\gettablelabel{testc}{pseudoSortByDistance}{NetworkTopologyImpl}{2}{\bookkeeper}}$} &
			\tcell{\unifdist{0.083}} &
			\tcell{$0.834$}
		\newtrow
	}
	
	%
	% Iter: 1, Class: BufferedChannel, Project: Bookkeeper
	%
	
	\ceqtable{write}{BufferedChannel}{1}{\bookkeeper}{
			\tcell{src} & \tcell{
				\ceq{null}\\
				\ceq{buffer a lunghezza $\ge$ 0}}
		\newtrow
	}
				
	\bvtable{write}{BufferedChannel}{1}{\bookkeeper}{
			\tcell{src} & \tcell{\ceq{null}} & \tcell{null}
		\newtrow
			\tcell{src} & \tcell{\ceq{buffer a lunghezza $\ge$ 0}} & \tcell{ByteBuf("")}
		\newtrow
	}
	
	\testctable{write}{BufferedChannel}{1}{\bookkeeper}{
			\tcell{null} & \tcell{IOException viene lanciata} & 
				\tcell{La documentazione specifica\\ 
						che se una write operation\\
						fallisce, allora viene lanciata\\
						una IOException. Non viene\\
						specificato nulla a riguardo\\
						del parametro src, assumiamo\\
						che se src è null,\\
						allora ricadiamo nel caso\\
						specificato dalla documentazione.}
		\newtrow
			\tcell{ByteBuf("")} & 
			\tcell{La scrittura nel buffer\\ avviene con successo} & 
			\tcell{}
		\newtrow
			\tcell{ByteBuf("random data")} &
			\tcell{La scrittura nel buffer\\ avviene con successo} &
			\tcell{}
		\newtrow
			\tcell{ByteBuf("more random data")} &
			\tcell{La scrittura nel buffer\\ avviene con successo} &
			\tcell{La scrittura è consecutiva a quella del test case\\
					precedente, non "sfora" il buffer}
		\newtrow
	}
	
	
			
	
\end{document}